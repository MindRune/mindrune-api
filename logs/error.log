{"level":"error","message":"500 - Unknown authentication strategy \"jwt\" - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-25 13:16:36"}
{"level":"error","message":"404 - Not Found - /osrs/scoreboard/oauth2%7Cdiscord%7C177946696251211776 - GET - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:01:40"}
{"level":"error","message":"404 - Not Found - /osrs/scoreboard/oauth2%7Cdiscord%7C177946696251211776 - GET - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:02:30"}
{"level":"error","message":"404 - Not Found - /osrs/scoreboard/oauth2%7Cdiscord%7C177946696251211776 - GET - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:03:05"}
{"level":"error","message":"404 - Not Found - /osrs/scoreboard/oauth2%7Cdiscord%7C177946696251211776 - GET - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:03:05"}
{"level":"error","message":"500 - Unknown authentication strategy \"jwt\" - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:03:05"}
{"level":"error","message":"500 - Unknown authentication strategy \"jwt\" - /user/registrationKey - POST - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:03:08"}
{"level":"error","message":"500 - Unknown authentication strategy \"jwt\" - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:10:46"}
{"level":"error","message":"404 - Not Found - /osrs/scoreboard/oauth2%7Cdiscord%7C177946696251211776 - GET - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:10:46"}
{"level":"error","message":"500 - Unknown authentication strategy \"jwt\" - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:10:46"}
{"level":"error","message":"404 - Not Found - /osrs/scoreboard/oauth2%7Cdiscord%7C177946696251211776 - GET - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:10:54"}
{"level":"error","message":"404 - Not Found - /osrs/scoreboard/oauth2%7Cdiscord%7C177946696251211776 - GET - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:10:54"}
{"level":"error","message":"500 - Unknown authentication strategy \"jwt\" - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:10:55"}
{"level":"error","message":"404 - Not Found - /osrs/scoreboard/oauth2%7Cdiscord%7C177946696251211776 - GET - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:11:03"}
{"level":"error","message":"404 - Not Found - /osrs/scoreboard/oauth2%7Cdiscord%7C177946696251211776 - GET - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:11:03"}
{"level":"error","message":"500 - Unknown authentication strategy \"jwt\" - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:11:03"}
{"level":"error","message":"500 - Unknown authentication strategy \"jwt\" - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:12:12"}
{"level":"error","message":"500 - Unknown authentication strategy \"jwt\" - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:12:12"}
{"level":"error","message":"500 - Unknown authentication strategy \"jwt\" - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:12:47"}
{"level":"error","message":"500 - Unknown authentication strategy \"jwt\" - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:12:47"}
{"level":"error","message":"404 - Not Found - /osrs/scoreboard/oauth2%7Cdiscord%7C177946696251211776 - GET - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:12:53"}
{"level":"error","message":"500 - Unknown authentication strategy \"jwt\" - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:12:53"}
{"level":"error","message":"500 - Unknown authentication strategy \"jwt\" - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:12:53"}
{"level":"error","message":"404 - Not Found - /osrs/scoreboard/oauth2%7Cdiscord%7C177946696251211776 - GET - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:15:09"}
{"level":"error","message":"500 - Unknown authentication strategy \"jwt\" - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:15:09"}
{"level":"error","message":"500 - Unknown authentication strategy \"jwt\" - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:15:09"}
{"level":"error","message":"404 - Not Found - /osrs/scoreboard/oauth2%7Cdiscord%7C177946696251211776 - GET - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:15:32"}
{"level":"error","message":"500 - Unknown authentication strategy \"jwt\" - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:15:32"}
{"level":"error","message":"500 - Unknown authentication strategy \"jwt\" - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:15:32"}
{"level":"error","message":"404 - Not Found - /osrs/scoreboard/oauth2%7Cdiscord%7C177946696251211776 - GET - ::1","service":"mindrune-api","timestamp":"2025-03-25 14:21:47"}
{"level":"error","message":"Error in Neo4j operations after 399ms: Cannot merge the following node because of null property value for 'name': (:Item {name: null})","service":"mindrune-api","timestamp":"2025-03-25 15:22:37"}
{"level":"error","message":"Error processing create request after 406ms: Cannot merge the following node because of null property value for 'name': (:Item {name: null})","service":"mindrune-api","timestamp":"2025-03-25 15:22:37"}
{"level":"error","message":"500 - Cannot merge the following node because of null property value for 'name': (:Item {name: null}) - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-25 15:22:37"}
{"level":"error","message":"Error in Neo4j operations after 247ms: Cannot merge the following node because of null property value for 'name': (:Item {name: null})","service":"mindrune-api","timestamp":"2025-03-25 15:26:47"}
{"level":"error","message":"Error processing create request after 250ms: Cannot merge the following node because of null property value for 'name': (:Item {name: null})","service":"mindrune-api","timestamp":"2025-03-25 15:26:47"}
{"level":"error","message":"500 - Cannot merge the following node because of null property value for 'name': (:Item {name: null}) - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-25 15:26:47"}
{"level":"error","message":"Error in Neo4j operations after 256ms: Invalid input '|': expected an expression, ',' or ']' (line 4, column 41 (offset: 167))\n\"      WHERE e.uuid IN [event.event_uuid | event IN $events WHERE event.hasLocation = true]\"\n                                         ^","service":"mindrune-api","timestamp":"2025-03-25 15:27:47"}
{"level":"error","message":"Error processing create request after 258ms: Invalid input '|': expected an expression, ',' or ']' (line 4, column 41 (offset: 167))\n\"      WHERE e.uuid IN [event.event_uuid | event IN $events WHERE event.hasLocation = true]\"\n                                         ^","service":"mindrune-api","timestamp":"2025-03-25 15:27:47"}
{"level":"error","message":"500 - Invalid input '|': expected an expression, ',' or ']' (line 4, column 41 (offset: 167))\n\"      WHERE e.uuid IN [event.event_uuid | event IN $events WHERE event.hasLocation = true]\"\n                                         ^ - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-25 15:27:47"}
{"level":"error","message":"Error in Neo4j operations after 1164ms: Invalid input '|': expected an expression, ',' or ']' (line 4, column 41 (offset: 167))\n\"      WHERE e.uuid IN [event.event_uuid | event IN $events WHERE event.hasLocation = true]\"\n                                         ^","service":"mindrune-api","timestamp":"2025-03-25 15:41:48"}
{"level":"error","message":"Error processing create request after 1170ms: Invalid input '|': expected an expression, ',' or ']' (line 4, column 41 (offset: 167))\n\"      WHERE e.uuid IN [event.event_uuid | event IN $events WHERE event.hasLocation = true]\"\n                                         ^","service":"mindrune-api","timestamp":"2025-03-25 15:41:48"}
{"level":"error","message":"500 - Invalid input '|': expected an expression, ',' or ']' (line 4, column 41 (offset: 167))\n\"      WHERE e.uuid IN [event.event_uuid | event IN $events WHERE event.hasLocation = true]\"\n                                         ^ - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-25 15:41:48"}
{"level":"error","message":"Error in Neo4j operations after 675ms: Invalid input '|': expected an expression, ',' or ']' (line 4, column 41 (offset: 167))\n\"      WHERE e.uuid IN [event.event_uuid | event IN $events WHERE event.hasLocation = true]\"\n                                         ^","service":"mindrune-api","timestamp":"2025-03-25 15:42:47"}
{"level":"error","message":"Error processing create request after 679ms: Invalid input '|': expected an expression, ',' or ']' (line 4, column 41 (offset: 167))\n\"      WHERE e.uuid IN [event.event_uuid | event IN $events WHERE event.hasLocation = true]\"\n                                         ^","service":"mindrune-api","timestamp":"2025-03-25 15:42:47"}
{"level":"error","message":"500 - Invalid input '|': expected an expression, ',' or ']' (line 4, column 41 (offset: 167))\n\"      WHERE e.uuid IN [event.event_uuid | event IN $events WHERE event.hasLocation = true]\"\n                                         ^ - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-25 15:42:47"}
{"level":"error","message":"Error in Neo4j operations after 705ms: Invalid input '|': expected an expression, ',' or ']' (line 4, column 41 (offset: 167))\n\"      WHERE e.uuid IN [event.event_uuid | event IN $events WHERE event.hasLocation = true]\"\n                                         ^","service":"mindrune-api","timestamp":"2025-03-25 15:43:47"}
{"level":"error","message":"Error processing create request after 711ms: Invalid input '|': expected an expression, ',' or ']' (line 4, column 41 (offset: 167))\n\"      WHERE e.uuid IN [event.event_uuid | event IN $events WHERE event.hasLocation = true]\"\n                                         ^","service":"mindrune-api","timestamp":"2025-03-25 15:43:47"}
{"level":"error","message":"500 - Invalid input '|': expected an expression, ',' or ']' (line 4, column 41 (offset: 167))\n\"      WHERE e.uuid IN [event.event_uuid | event IN $events WHERE event.hasLocation = true]\"\n                                         ^ - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-25 15:43:47"}
{"level":"error","message":"404 - Not Found - /image/mind-rune.webp - GET - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-25 16:34:30"}
{"level":"error","message":"404 - Not Found - /favicon.ico - GET - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-25 16:34:30"}
{"level":"error","message":"404 - Not Found - /image/mind-rune - GET - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-25 16:49:49"}
{"level":"error","message":"404 - Not Found - /favicon.ico - GET - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-25 16:49:49"}
{"level":"error","message":"404 - Not Found - /image/mind-rune - GET - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-25 16:50:54"}
{"level":"error","message":"404 - Not Found - /favicon.ico - GET - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-25 16:50:55"}
{"level":"error","message":"404 - Not Found - /image/mind-rune.webp - GET - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-25 16:54:30"}
{"level":"error","message":"404 - Not Found - /favicon.ico - GET - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-25 16:54:30"}
{"level":"error","message":"500 - Image not found - /img/mind-rune.webp - GET - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-25 16:55:35"}
{"level":"error","message":"404 - Not Found - /favicon.ico - GET - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-25 16:55:35"}
{"level":"error","message":"404 - Not Found - /favicon.ico - GET - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-25 16:55:54"}
{"level":"error","message":"Error in Neo4j operations after 100ms: npcName.trim is not a function","service":"mindrune-api","timestamp":"2025-03-26 13:26:16"}
{"level":"error","message":"Error processing create request after 104ms: npcName.trim is not a function","service":"mindrune-api","timestamp":"2025-03-26 13:26:16"}
{"level":"error","message":"500 - npcName.trim is not a function - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-26 13:26:16"}
{"level":"error","message":"Error in Neo4j operations after 91ms: npcName.trim is not a function","service":"mindrune-api","timestamp":"2025-03-26 13:27:16"}
{"level":"error","message":"Error processing create request after 93ms: npcName.trim is not a function","service":"mindrune-api","timestamp":"2025-03-26 13:27:16"}
{"level":"error","message":"500 - npcName.trim is not a function - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-26 13:27:16"}
{"level":"error","message":"Error in Neo4j operations after 102ms: npcName.trim is not a function","service":"mindrune-api","timestamp":"2025-03-26 13:28:16"}
{"level":"error","message":"Error processing create request after 106ms: npcName.trim is not a function","service":"mindrune-api","timestamp":"2025-03-26 13:28:16"}
{"level":"error","message":"500 - npcName.trim is not a function - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-26 13:28:16"}
{"level":"error","message":"Error in Neo4j operations after 380ms: cleanedName.indexOf is not a function","service":"mindrune-api","timestamp":"2025-03-26 13:29:16"}
{"level":"error","message":"Error processing create request after 386ms: cleanedName.indexOf is not a function","service":"mindrune-api","timestamp":"2025-03-26 13:29:16"}
{"level":"error","message":"500 - cleanedName.indexOf is not a function - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-26 13:29:16"}
{"level":"error","message":"Error in Neo4j operations after 358ms: cleanedName.indexOf is not a function","service":"mindrune-api","timestamp":"2025-03-26 13:30:16"}
{"level":"error","message":"Error processing create request after 361ms: cleanedName.indexOf is not a function","service":"mindrune-api","timestamp":"2025-03-26 13:30:16"}
{"level":"error","message":"500 - cleanedName.indexOf is not a function - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-26 13:30:16"}
{"level":"error","message":"Error in Neo4j operations after 101ms: cleanedName.indexOf is not a function","service":"mindrune-api","timestamp":"2025-03-26 13:31:16"}
{"level":"error","message":"Error processing create request after 104ms: cleanedName.indexOf is not a function","service":"mindrune-api","timestamp":"2025-03-26 13:31:16"}
{"level":"error","message":"500 - cleanedName.indexOf is not a function - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-26 13:31:16"}
{"level":"error","message":"Error in Neo4j operations after 93ms: cleanedName.indexOf is not a function","service":"mindrune-api","timestamp":"2025-03-26 13:32:16"}
{"level":"error","message":"Error processing create request after 96ms: cleanedName.indexOf is not a function","service":"mindrune-api","timestamp":"2025-03-26 13:32:16"}
{"level":"error","message":"500 - cleanedName.indexOf is not a function - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-26 13:32:16"}
{"level":"error","message":"Error in Neo4j operations after 93ms: cleanedName.indexOf is not a function","service":"mindrune-api","timestamp":"2025-03-26 13:33:16"}
{"level":"error","message":"Error processing create request after 96ms: cleanedName.indexOf is not a function","service":"mindrune-api","timestamp":"2025-03-26 13:33:16"}
{"level":"error","message":"500 - cleanedName.indexOf is not a function - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-26 13:33:16"}
{"level":"error","message":"Error in Neo4j operations after 201ms: Variable `event` already declared in outer scope (line 18, column 19 (offset: 561))\n\"        RETURN e, event\"\n                   ^","service":"mindrune-api","timestamp":"2025-03-26 15:38:13"}
{"level":"error","message":"Error processing create request after 203ms: Variable `event` already declared in outer scope (line 18, column 19 (offset: 561))\n\"        RETURN e, event\"\n                   ^","service":"mindrune-api","timestamp":"2025-03-26 15:38:13"}
{"level":"error","message":"500 - Variable `event` already declared in outer scope (line 18, column 19 (offset: 561))\n\"        RETURN e, event\"\n                   ^ - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-26 15:38:13"}
{"level":"error","message":"Error in Neo4j operations after 260ms: Variable `event` already declared in outer scope (line 18, column 19 (offset: 561))\n\"        RETURN e, event\"\n                   ^","service":"mindrune-api","timestamp":"2025-03-26 15:39:13"}
{"level":"error","message":"Error processing create request after 263ms: Variable `event` already declared in outer scope (line 18, column 19 (offset: 561))\n\"        RETURN e, event\"\n                   ^","service":"mindrune-api","timestamp":"2025-03-26 15:39:13"}
{"level":"error","message":"500 - Variable `event` already declared in outer scope (line 18, column 19 (offset: 561))\n\"        RETURN e, event\"\n                   ^ - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-26 15:39:13"}
{"level":"error","message":"Error in Neo4j operations after 92ms: event.details.source.replace is not a function","service":"mindrune-api","timestamp":"2025-03-26 16:06:15"}
{"level":"error","message":"Error processing create request after 94ms: event.details.source.replace is not a function","service":"mindrune-api","timestamp":"2025-03-26 16:06:15"}
{"level":"error","message":"500 - event.details.source.replace is not a function - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-26 16:06:15"}
{"level":"error","message":"Error in Neo4j operations after 100ms: event.details.source.replace is not a function","service":"mindrune-api","timestamp":"2025-03-26 16:07:15"}
{"level":"error","message":"Error processing create request after 103ms: event.details.source.replace is not a function","service":"mindrune-api","timestamp":"2025-03-26 16:07:15"}
{"level":"error","message":"500 - event.details.source.replace is not a function - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-26 16:07:15"}
{"level":"error","message":"Error in Neo4j operations after 91ms: event.details.source.replace is not a function","service":"mindrune-api","timestamp":"2025-03-26 16:08:15"}
{"level":"error","message":"Error processing create request after 94ms: event.details.source.replace is not a function","service":"mindrune-api","timestamp":"2025-03-26 16:08:15"}
{"level":"error","message":"500 - event.details.source.replace is not a function - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-26 16:08:15"}
{"level":"error","message":"Error in Neo4j operations after 101ms: event.details.source.replace is not a function","service":"mindrune-api","timestamp":"2025-03-26 16:09:15"}
{"level":"error","message":"Error processing create request after 105ms: event.details.source.replace is not a function","service":"mindrune-api","timestamp":"2025-03-26 16:09:15"}
{"level":"error","message":"500 - event.details.source.replace is not a function - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-26 16:09:15"}
{"level":"error","message":"Error in Neo4j operations after 1844ms: WITH is required between CREATE and MATCH (line 28, column 7 (offset: 837))\n\"      MATCH (character:Character {name: event.target})\"\n       ^","service":"mindrune-api","timestamp":"2025-03-26 18:57:54"}
{"level":"error","message":"Error processing create request after 1851ms: WITH is required between CREATE and MATCH (line 28, column 7 (offset: 837))\n\"      MATCH (character:Character {name: event.target})\"\n       ^","service":"mindrune-api","timestamp":"2025-03-26 18:57:54"}
{"level":"error","message":"500 - WITH is required between CREATE and MATCH (line 28, column 7 (offset: 837))\n\"      MATCH (character:Character {name: event.target})\"\n       ^ - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-26 18:57:54"}
{"level":"error","message":"Error in Neo4j operations after 1038ms: WITH is required between CREATE and MATCH (line 18, column 11 (offset: 529))\n\"          MATCH (reward:Reward {rewardId: event.rewardId})\"\n           ^","service":"mindrune-api","timestamp":"2025-03-28 22:16:39"}
{"level":"error","message":"Error processing create request after 1041ms: WITH is required between CREATE and MATCH (line 18, column 11 (offset: 529))\n\"          MATCH (reward:Reward {rewardId: event.rewardId})\"\n           ^","service":"mindrune-api","timestamp":"2025-03-28 22:16:39"}
{"level":"error","message":"500 - WITH is required between CREATE and MATCH (line 18, column 11 (offset: 529))\n\"          MATCH (reward:Reward {rewardId: event.rewardId})\"\n           ^ - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-28 22:16:39"}
{"level":"error","message":"Error in Neo4j operations after 1230ms: WITH is required between CREATE and MATCH (line 18, column 11 (offset: 529))\n\"          MATCH (reward:Reward {rewardId: event.rewardId})\"\n           ^","service":"mindrune-api","timestamp":"2025-03-29 07:55:05"}
{"level":"error","message":"Error processing create request after 1233ms: WITH is required between CREATE and MATCH (line 18, column 11 (offset: 529))\n\"          MATCH (reward:Reward {rewardId: event.rewardId})\"\n           ^","service":"mindrune-api","timestamp":"2025-03-29 07:55:05"}
{"level":"error","message":"500 - WITH is required between CREATE and MATCH (line 18, column 11 (offset: 529))\n\"          MATCH (reward:Reward {rewardId: event.rewardId})\"\n           ^ - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-29 07:55:05"}
{"level":"error","message":"Error in Neo4j operations after 1438ms: Invalid input 'WHERE': expected 'FOREACH', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'WITH' or <EOF> (line 5, column 7 (offset: 113))\n\"      WHERE event.isTargetDamageType = false // Skip events where target is a damage type\"\n       ^","service":"mindrune-api","timestamp":"2025-03-29 09:11:04"}
{"level":"error","message":"Error processing create request after 1450ms: Invalid input 'WHERE': expected 'FOREACH', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'WITH' or <EOF> (line 5, column 7 (offset: 113))\n\"      WHERE event.isTargetDamageType = false // Skip events where target is a damage type\"\n       ^","service":"mindrune-api","timestamp":"2025-03-29 09:11:04"}
{"level":"error","message":"500 - Invalid input 'WHERE': expected 'FOREACH', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'WITH' or <EOF> (line 5, column 7 (offset: 113))\n\"      WHERE event.isTargetDamageType = false // Skip events where target is a damage type\"\n       ^ - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-29 09:11:04"}
{"level":"error","message":"Error in Neo4j operations after 1469ms: Invalid input 'WHERE': expected 'FOREACH', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'WITH' or <EOF> (line 5, column 7 (offset: 113))\n\"      WHERE event.isTargetDamageType = false // Skip events where target is a damage type\"\n       ^","service":"mindrune-api","timestamp":"2025-03-29 09:12:04"}
{"level":"error","message":"Error processing create request after 1473ms: Invalid input 'WHERE': expected 'FOREACH', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'WITH' or <EOF> (line 5, column 7 (offset: 113))\n\"      WHERE event.isTargetDamageType = false // Skip events where target is a damage type\"\n       ^","service":"mindrune-api","timestamp":"2025-03-29 09:12:04"}
{"level":"error","message":"500 - Invalid input 'WHERE': expected 'FOREACH', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'WITH' or <EOF> (line 5, column 7 (offset: 113))\n\"      WHERE event.isTargetDamageType = false // Skip events where target is a damage type\"\n       ^ - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-29 09:12:04"}
{"level":"error","message":"Error in Neo4j operations after 1019ms: Invalid input 'WHERE': expected 'FOREACH', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'WITH' or <EOF> (line 5, column 7 (offset: 113))\n\"      WHERE event.isTargetDamageType = false // Skip events where target is a damage type\"\n       ^","service":"mindrune-api","timestamp":"2025-03-29 09:13:04"}
{"level":"error","message":"Error processing create request after 1022ms: Invalid input 'WHERE': expected 'FOREACH', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'WITH' or <EOF> (line 5, column 7 (offset: 113))\n\"      WHERE event.isTargetDamageType = false // Skip events where target is a damage type\"\n       ^","service":"mindrune-api","timestamp":"2025-03-29 09:13:04"}
{"level":"error","message":"500 - Invalid input 'WHERE': expected 'FOREACH', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'WITH' or <EOF> (line 5, column 7 (offset: 113))\n\"      WHERE event.isTargetDamageType = false // Skip events where target is a damage type\"\n       ^ - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-29 09:13:04"}
{"level":"error","message":"Error in Neo4j operations after 1263ms: All sub queries in an UNION must have the same return column names (line 47, column 9 (offset: 1594))\n\"        UNION\"\n         ^","service":"mindrune-api","timestamp":"2025-03-29 09:25:04"}
{"level":"error","message":"Error processing create request after 1266ms: All sub queries in an UNION must have the same return column names (line 47, column 9 (offset: 1594))\n\"        UNION\"\n         ^","service":"mindrune-api","timestamp":"2025-03-29 09:25:04"}
{"level":"error","message":"500 - All sub queries in an UNION must have the same return column names (line 47, column 9 (offset: 1594))\n\"        UNION\"\n         ^ - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-29 09:25:04"}
{"level":"error","message":"Error in Neo4j operations after 589ms: All sub queries in an UNION must have the same return column names (line 47, column 9 (offset: 1594))\n\"        UNION\"\n         ^","service":"mindrune-api","timestamp":"2025-03-29 09:26:03"}
{"level":"error","message":"Error processing create request after 591ms: All sub queries in an UNION must have the same return column names (line 47, column 9 (offset: 1594))\n\"        UNION\"\n         ^","service":"mindrune-api","timestamp":"2025-03-29 09:26:03"}
{"level":"error","message":"500 - All sub queries in an UNION must have the same return column names (line 47, column 9 (offset: 1594))\n\"        UNION\"\n         ^ - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-29 09:26:03"}
{"level":"error","message":"Error in Neo4j operations after 742ms: All sub queries in an UNION must have the same return column names (line 47, column 9 (offset: 1594))\n\"        UNION\"\n         ^","service":"mindrune-api","timestamp":"2025-03-29 09:27:04"}
{"level":"error","message":"Error processing create request after 747ms: All sub queries in an UNION must have the same return column names (line 47, column 9 (offset: 1594))\n\"        UNION\"\n         ^","service":"mindrune-api","timestamp":"2025-03-29 09:27:04"}
{"level":"error","message":"500 - All sub queries in an UNION must have the same return column names (line 47, column 9 (offset: 1594))\n\"        UNION\"\n         ^ - /osrs/create - POST - ::ffff:127.0.0.1","service":"mindrune-api","timestamp":"2025-03-29 09:27:04"}
{"level":"error","message":"Neo4j error: Unknown function 'starts_with' (line 10, column 14 (offset: 332))\n\"          OR starts_with(type(r1), 'PERFORMED')\"\n              ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n        MATCH (p:Player {account: $account})\n        \n        // For multi-player, we'll get fewer events per player\n        WITH p\n        \n        // First get events where player is the target\n        OPTIONAL MATCH (e1)-[r1]->(p)\n        WHERE type(r1) IN ['PERFORMED_BY', 'GAINED_BY', 'RECEIVED_BY', 'TARGETED'] \n          OR starts_with(type(r1), 'PERFORMED') \n          OR starts_with(type(r1), 'TARGETED')\n        \n        // Also get events where player is the source\n        OPTIONAL MATCH (p)-[r2]->(e2)\n        WHERE type(r2) IN ['PERFORMED', 'KILLED'] \n          OR starts_with(type(r2), 'PERFORMED')\n        \n        // Group by player and collect events\n        WITH p, collect(distinct e1) + collect(distinct e2) as player_events\n        \n        // Limit events per player and collect all players\n        WITH p, player_events[0..500] as limited_events\n        ORDER BY p.playerId\n        \n        // Collect all players and their events\n        WITH collect({player: p, events: limited_events}) as player_data\n        \n        // Unwind and collect all events\n        UNWIND player_data as pd\n        UNWIND pd.events as event\n        WITH collect(distinct pd.player) as players, collect(distinct event) as events\n        \n        // Now process relationships for these events\n        UNWIND events as e\n        \n        // Get outgoing relationships from events\n        OPTIONAL MATCH (e)-[r1]->(n1)\n        WHERE NOT type(r1) IN ['PART_OF']\n        \n        // Get incoming relationships to events\n        OPTIONAL MATCH (n2)-[r2]->(e)\n        WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n        \n        RETURN \n          players,\n          events,\n          collect(distinct n1) + collect(distinct n2) as entities,\n          collect(distinct r1) + collect(distinct r2) as relationships\n        ","service":"mindrune-api","timestamp":"2025-03-29 14:15:36"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'starts_with' (line 10, column 14 (offset: 332))\n\"          OR starts_with(type(r1), 'PERFORMED')\"\n              ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 14:15:36"}
{"level":"error","message":"Neo4j error: Unknown function 'starts_with' (line 10, column 14 (offset: 332))\n\"          OR starts_with(type(r1), 'PERFORMED')\"\n              ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n        MATCH (p:Player {account: $account})\n        \n        // For multi-player, we'll get fewer events per player\n        WITH p\n        \n        // First get events where player is the target\n        OPTIONAL MATCH (e1)-[r1]->(p)\n        WHERE type(r1) IN ['PERFORMED_BY', 'GAINED_BY', 'RECEIVED_BY', 'TARGETED'] \n          OR starts_with(type(r1), 'PERFORMED') \n          OR starts_with(type(r1), 'TARGETED')\n        \n        // Also get events where player is the source\n        OPTIONAL MATCH (p)-[r2]->(e2)\n        WHERE type(r2) IN ['PERFORMED', 'KILLED'] \n          OR starts_with(type(r2), 'PERFORMED')\n        \n        // Group by player and collect events\n        WITH p, collect(distinct e1) + collect(distinct e2) as player_events\n        \n        // Limit events per player and collect all players\n        WITH p, player_events[0..500] as limited_events\n        ORDER BY p.playerId\n        \n        // Collect all players and their events\n        WITH collect({player: p, events: limited_events}) as player_data\n        \n        // Unwind and collect all events\n        UNWIND player_data as pd\n        UNWIND pd.events as event\n        WITH collect(distinct pd.player) as players, collect(distinct event) as events\n        \n        // Now process relationships for these events\n        UNWIND events as e\n        \n        // Get outgoing relationships from events\n        OPTIONAL MATCH (e)-[r1]->(n1)\n        WHERE NOT type(r1) IN ['PART_OF']\n        \n        // Get incoming relationships to events\n        OPTIONAL MATCH (n2)-[r2]->(e)\n        WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n        \n        RETURN \n          players,\n          events,\n          collect(distinct n1) + collect(distinct n2) as entities,\n          collect(distinct r1) + collect(distinct r2) as relationships\n        ","service":"mindrune-api","timestamp":"2025-03-29 14:15:36"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'starts_with' (line 10, column 14 (offset: 332))\n\"          OR starts_with(type(r1), 'PERFORMED')\"\n              ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 14:15:36"}
{"level":"error","message":"Neo4j error: Unknown function 'starts_with' (line 10, column 14 (offset: 332))\n\"          OR starts_with(type(r1), 'PERFORMED')\"\n              ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n        MATCH (p:Player {account: $account})\n        \n        // For multi-player, we'll get fewer events per player\n        WITH p\n        \n        // First get events where player is the target\n        OPTIONAL MATCH (e1)-[r1]->(p)\n        WHERE type(r1) IN ['PERFORMED_BY', 'GAINED_BY', 'RECEIVED_BY', 'TARGETED'] \n          OR starts_with(type(r1), 'PERFORMED') \n          OR starts_with(type(r1), 'TARGETED')\n        \n        // Also get events where player is the source\n        OPTIONAL MATCH (p)-[r2]->(e2)\n        WHERE type(r2) IN ['PERFORMED', 'KILLED'] \n          OR starts_with(type(r2), 'PERFORMED')\n        \n        // Group by player and collect events\n        WITH p, collect(distinct e1) + collect(distinct e2) as player_events\n        \n        // Limit events per player and collect all players\n        WITH p, player_events[0..500] as limited_events\n        ORDER BY p.playerId\n        \n        // Collect all players and their events\n        WITH collect({player: p, events: limited_events}) as player_data\n        \n        // Unwind and collect all events\n        UNWIND player_data as pd\n        UNWIND pd.events as event\n        WITH collect(distinct pd.player) as players, collect(distinct event) as events\n        \n        // Now process relationships for these events\n        UNWIND events as e\n        \n        // Get outgoing relationships from events\n        OPTIONAL MATCH (e)-[r1]->(n1)\n        WHERE NOT type(r1) IN ['PART_OF']\n        \n        // Get incoming relationships to events\n        OPTIONAL MATCH (n2)-[r2]->(e)\n        WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n        \n        RETURN \n          players,\n          events,\n          collect(distinct n1) + collect(distinct n2) as entities,\n          collect(distinct r1) + collect(distinct r2) as relationships\n        ","service":"mindrune-api","timestamp":"2025-03-29 14:15:42"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'starts_with' (line 10, column 14 (offset: 332))\n\"          OR starts_with(type(r1), 'PERFORMED')\"\n              ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 14:15:42"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 9, column 16 (offset: 245))\n\"        RETURN p, e\"\n                ^","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      MATCH (p:Player {account: $account})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management\n      CALL {\n        WITH p\n        // Use UNION for better optimization\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN p, e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN p, e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN p, e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN p, e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN p, e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN p, e\n      }\n      \n      // Group events by player using WITH and collect for better memory management\n      WITH p, e ORDER BY e.timestamp DESC\n      WITH p, collect(e)[0..$eventsPerPlayer] as player_events\n      \n      // Collect all players and their events\n      WITH collect({player: p, events: player_events}) as player_data\n      \n      // Process the collected data more efficiently\n      UNWIND player_data as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten the events while maintaining the player association\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:26:12"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 9, column 16 (offset: 245))\n\"        RETURN p, e\"\n                ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:26:12"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 9, column 16 (offset: 245))\n\"        RETURN p, e\"\n                ^","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      MATCH (p:Player {account: $account})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management\n      CALL {\n        WITH p\n        // Use UNION for better optimization\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN p, e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN p, e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN p, e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN p, e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN p, e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN p, e\n      }\n      \n      // Group events by player using WITH and collect for better memory management\n      WITH p, e ORDER BY e.timestamp DESC\n      WITH p, collect(e)[0..$eventsPerPlayer] as player_events\n      \n      // Collect all players and their events\n      WITH collect({player: p, events: player_events}) as player_data\n      \n      // Process the collected data more efficiently\n      UNWIND player_data as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten the events while maintaining the player association\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:26:12"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 9, column 16 (offset: 245))\n\"        RETURN p, e\"\n                ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:26:12"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 9, column 16 (offset: 245))\n\"        RETURN p, e\"\n                ^","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      MATCH (p:Player {account: $account})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management\n      CALL {\n        WITH p\n        // Use UNION for better optimization\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN p, e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN p, e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN p, e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN p, e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN p, e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN p, e\n      }\n      \n      // Group events by player using WITH and collect for better memory management\n      WITH p, e ORDER BY e.timestamp DESC\n      WITH p, collect(e)[0..$eventsPerPlayer] as player_events\n      \n      // Collect all players and their events\n      WITH collect({player: p, events: player_events}) as player_data\n      \n      // Process the collected data more efficiently\n      UNWIND player_data as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten the events while maintaining the player association\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:29:12"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 9, column 16 (offset: 245))\n\"        RETURN p, e\"\n                ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:29:12"}
{"level":"error","message":"Neo4j error: Variable `player` already declared in outer scope (line 8, column 16 (offset: 235))\n\"        RETURN player, e\"\n                ^","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      MATCH (player:Player {account: $account})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with proper scoping\n      CALL {\n        WITH player\n        MATCH (e)-[:PERFORMED_BY]->(player) \n        RETURN player, e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(player) \n        RETURN player, e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(player) \n        RETURN player, e\n        UNION\n        MATCH (e)-[:TARGETED]->(player) \n        RETURN player, e\n        UNION\n        MATCH (player)-[:PERFORMED]->(e) \n        RETURN player, e\n        UNION\n        MATCH (player)-[:KILLED]->(e) \n        RETURN player, e\n      }\n      \n      // Group events by player using WITH and collect for better memory management\n      WITH player, e ORDER BY e.timestamp DESC\n      WITH player, collect(e)[0..$eventsPerPlayer] as player_events\n      \n      // Collect all players and their events\n      WITH collect({player: player, events: player_events}) as player_data\n      \n      // Process the collected data more efficiently\n      UNWIND player_data as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten the events while maintaining the player association\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:32:51"}
{"level":"error","message":"500 - Neo4j error: Variable `player` already declared in outer scope (line 8, column 16 (offset: 235))\n\"        RETURN player, e\"\n                ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:32:51"}
{"level":"error","message":"Neo4j error: Variable `player` already declared in outer scope (line 8, column 16 (offset: 235))\n\"        RETURN player, e\"\n                ^","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      MATCH (player:Player {account: $account})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with proper scoping\n      CALL {\n        WITH player\n        MATCH (e)-[:PERFORMED_BY]->(player) \n        RETURN player, e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(player) \n        RETURN player, e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(player) \n        RETURN player, e\n        UNION\n        MATCH (e)-[:TARGETED]->(player) \n        RETURN player, e\n        UNION\n        MATCH (player)-[:PERFORMED]->(e) \n        RETURN player, e\n        UNION\n        MATCH (player)-[:KILLED]->(e) \n        RETURN player, e\n      }\n      \n      // Group events by player using WITH and collect for better memory management\n      WITH player, e ORDER BY e.timestamp DESC\n      WITH player, collect(e)[0..$eventsPerPlayer] as player_events\n      \n      // Collect all players and their events\n      WITH collect({player: player, events: player_events}) as player_data\n      \n      // Process the collected data more efficiently\n      UNWIND player_data as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten the events while maintaining the player association\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:32:51"}
{"level":"error","message":"500 - Neo4j error: Variable `player` already declared in outer scope (line 8, column 16 (offset: 235))\n\"        RETURN player, e\"\n                ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:32:51"}
{"level":"error","message":"Neo4j error: Variable `player` already declared in outer scope (line 8, column 16 (offset: 235))\n\"        RETURN player, e\"\n                ^","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      MATCH (player:Player {account: $account})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with proper scoping\n      CALL {\n        WITH player\n        MATCH (e)-[:PERFORMED_BY]->(player) \n        RETURN player, e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(player) \n        RETURN player, e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(player) \n        RETURN player, e\n        UNION\n        MATCH (e)-[:TARGETED]->(player) \n        RETURN player, e\n        UNION\n        MATCH (player)-[:PERFORMED]->(e) \n        RETURN player, e\n        UNION\n        MATCH (player)-[:KILLED]->(e) \n        RETURN player, e\n      }\n      \n      // Group events by player using WITH and collect for better memory management\n      WITH player, e ORDER BY e.timestamp DESC\n      WITH player, collect(e)[0..$eventsPerPlayer] as player_events\n      \n      // Collect all players and their events\n      WITH collect({player: player, events: player_events}) as player_data\n      \n      // Process the collected data more efficiently\n      UNWIND player_data as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten the events while maintaining the player association\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:40:48"}
{"level":"error","message":"500 - Neo4j error: Variable `player` already declared in outer scope (line 8, column 16 (offset: 235))\n\"        RETURN player, e\"\n                ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:40:48"}
{"level":"error","message":"Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 29 (offset: 1656))\n\"        WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                             ^","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n        // Get all players for this account\n        MATCH (players:Player {account: $account})\n        \n        // Collect the players first\n        WITH collect(players) as allPlayers\n        \n        // Process each player separately to get their events\n        UNWIND allPlayers as currentPlayer\n        \n        // For each player, find events with various relationships in batches\n        // This avoids variable scope issues with CALL blocks\n        MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n        WITH currentPlayer, collect(events) as type1Events\n        \n        MATCH (events)-[:GAINED_BY]->(currentPlayer)\n        WITH currentPlayer, type1Events, collect(events) as type2Events\n        \n        MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n        WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n        \n        MATCH (events)-[:TARGETED]->(currentPlayer)\n        WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n        \n        MATCH (currentPlayer)-[:PERFORMED]->(events)\n        WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n        \n        MATCH (currentPlayer)-[:KILLED]->(events)\n        WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n        \n        // Combine all event types and sort by timestamp\n        WITH currentPlayer, \n             type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n        \n        // To remove duplicates more efficiently\n        WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\n        \n        // Sort events by timestamp and take only the most recent ones\n        WITH currentPlayer, uniqueEvents\n        UNWIND uniqueEvents as event\n        WITH currentPlayer, event\n        ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n        \n        // Collect player-specific events\n        WITH currentPlayer, collect(event) as playerEvents\n        \n        // Add to our result collection of player-event pairs\n        WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n        \n        // Now process all the relationships for visualization\n        UNWIND playerData as pd\n        WITH pd.player as player, pd.events as events\n        \n        // Flatten events for relationship discovery\n        UNWIND events as event\n        \n        // Get outgoing relationships from events\n        OPTIONAL MATCH (event)-[r1]->(n1)\n        WHERE NOT type(r1) = \"PART_OF\"\n        \n        // Get incoming relationships to events\n        OPTIONAL MATCH (n2)-[r2]->(event)\n        WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n        \n        // Collect all the results\n        RETURN \n          collect(distinct player) as players,\n          collect(distinct event) as events,\n          collect(distinct n1) + collect(distinct n2) as entities,\n          collect(distinct r1) + collect(distinct r2) as relationships\n        ","service":"mindrune-api","timestamp":"2025-03-29 16:46:18"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 29 (offset: 1656))\n\"        WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                             ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:46:18"}
{"level":"error","message":"Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 29 (offset: 1656))\n\"        WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                             ^","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n        // Get all players for this account\n        MATCH (players:Player {account: $account})\n        \n        // Collect the players first\n        WITH collect(players) as allPlayers\n        \n        // Process each player separately to get their events\n        UNWIND allPlayers as currentPlayer\n        \n        // For each player, find events with various relationships in batches\n        // This avoids variable scope issues with CALL blocks\n        MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n        WITH currentPlayer, collect(events) as type1Events\n        \n        MATCH (events)-[:GAINED_BY]->(currentPlayer)\n        WITH currentPlayer, type1Events, collect(events) as type2Events\n        \n        MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n        WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n        \n        MATCH (events)-[:TARGETED]->(currentPlayer)\n        WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n        \n        MATCH (currentPlayer)-[:PERFORMED]->(events)\n        WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n        \n        MATCH (currentPlayer)-[:KILLED]->(events)\n        WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n        \n        // Combine all event types and sort by timestamp\n        WITH currentPlayer, \n             type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n        \n        // To remove duplicates more efficiently\n        WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\n        \n        // Sort events by timestamp and take only the most recent ones\n        WITH currentPlayer, uniqueEvents\n        UNWIND uniqueEvents as event\n        WITH currentPlayer, event\n        ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n        \n        // Collect player-specific events\n        WITH currentPlayer, collect(event) as playerEvents\n        \n        // Add to our result collection of player-event pairs\n        WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n        \n        // Now process all the relationships for visualization\n        UNWIND playerData as pd\n        WITH pd.player as player, pd.events as events\n        \n        // Flatten events for relationship discovery\n        UNWIND events as event\n        \n        // Get outgoing relationships from events\n        OPTIONAL MATCH (event)-[r1]->(n1)\n        WHERE NOT type(r1) = \"PART_OF\"\n        \n        // Get incoming relationships to events\n        OPTIONAL MATCH (n2)-[r2]->(event)\n        WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n        \n        // Collect all the results\n        RETURN \n          collect(distinct player) as players,\n          collect(distinct event) as events,\n          collect(distinct n1) + collect(distinct n2) as entities,\n          collect(distinct r1) + collect(distinct r2) as relationships\n        ","service":"mindrune-api","timestamp":"2025-03-29 16:46:18"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 29 (offset: 1656))\n\"        WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                             ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:46:18"}
{"level":"error","message":"Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 29 (offset: 1656))\n\"        WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                             ^","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n        // Get all players for this account\n        MATCH (players:Player {account: $account})\n        \n        // Collect the players first\n        WITH collect(players) as allPlayers\n        \n        // Process each player separately to get their events\n        UNWIND allPlayers as currentPlayer\n        \n        // For each player, find events with various relationships in batches\n        // This avoids variable scope issues with CALL blocks\n        MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n        WITH currentPlayer, collect(events) as type1Events\n        \n        MATCH (events)-[:GAINED_BY]->(currentPlayer)\n        WITH currentPlayer, type1Events, collect(events) as type2Events\n        \n        MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n        WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n        \n        MATCH (events)-[:TARGETED]->(currentPlayer)\n        WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n        \n        MATCH (currentPlayer)-[:PERFORMED]->(events)\n        WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n        \n        MATCH (currentPlayer)-[:KILLED]->(events)\n        WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n        \n        // Combine all event types and sort by timestamp\n        WITH currentPlayer, \n             type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n        \n        // To remove duplicates more efficiently\n        WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\n        \n        // Sort events by timestamp and take only the most recent ones\n        WITH currentPlayer, uniqueEvents\n        UNWIND uniqueEvents as event\n        WITH currentPlayer, event\n        ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n        \n        // Collect player-specific events\n        WITH currentPlayer, collect(event) as playerEvents\n        \n        // Add to our result collection of player-event pairs\n        WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n        \n        // Now process all the relationships for visualization\n        UNWIND playerData as pd\n        WITH pd.player as player, pd.events as events\n        \n        // Flatten events for relationship discovery\n        UNWIND events as event\n        \n        // Get outgoing relationships from events\n        OPTIONAL MATCH (event)-[r1]->(n1)\n        WHERE NOT type(r1) = \"PART_OF\"\n        \n        // Get incoming relationships to events\n        OPTIONAL MATCH (n2)-[r2]->(event)\n        WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n        \n        // Collect all the results\n        RETURN \n          collect(distinct player) as players,\n          collect(distinct event) as events,\n          collect(distinct n1) + collect(distinct n2) as entities,\n          collect(distinct r1) + collect(distinct r2) as relationships\n        ","service":"mindrune-api","timestamp":"2025-03-29 16:46:21"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 29 (offset: 1656))\n\"        WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                             ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:46:21"}
{"level":"error","message":"Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer.","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n        // Get all players for this account\n        MATCH (players:Player {account: $account})\n        \n        // Collect the players first\n        WITH collect(players) as allPlayers\n        \n        // Process each player separately to get their events\n        UNWIND allPlayers as currentPlayer\n        \n        // For each player, find events with various relationships in batches\n        // This avoids variable scope issues with CALL blocks\n        MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n        WITH currentPlayer, collect(events) as type1Events\n        \n        MATCH (events)-[:GAINED_BY]->(currentPlayer)\n        WITH currentPlayer, type1Events, collect(events) as type2Events\n        \n        MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n        WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n        \n        MATCH (events)-[:TARGETED]->(currentPlayer)\n        WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n        \n        MATCH (currentPlayer)-[:PERFORMED]->(events)\n        WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n        \n        MATCH (currentPlayer)-[:KILLED]->(events)\n        WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n        \n        // Combine all event types and sort by timestamp\n        WITH currentPlayer, \n             type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n        \n        // To remove duplicates more efficiently\n        WITH currentPlayer, combinedEvents as events\nUNWIND events as event\nWITH currentPlayer, event\nWHERE event IS NOT NULL\nWITH currentPlayer, collect(DISTINCT event) as uniqueEvents\n        \n        // Sort events by timestamp and take only the most recent ones\n        WITH currentPlayer, uniqueEvents\n        UNWIND uniqueEvents as event\n        WITH currentPlayer, event\n        ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n        \n        // Collect player-specific events\n        WITH currentPlayer, collect(event) as playerEvents\n        \n        // Add to our result collection of player-event pairs\n        WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n        \n        // Now process all the relationships for visualization\n        UNWIND playerData as pd\n        WITH pd.player as player, pd.events as events\n        \n        // Flatten events for relationship discovery\n        UNWIND events as event\n        \n        // Get outgoing relationships from events\n        OPTIONAL MATCH (event)-[r1]->(n1)\n        WHERE NOT type(r1) = \"PART_OF\"\n        \n        // Get incoming relationships to events\n        OPTIONAL MATCH (n2)-[r2]->(event)\n        WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n        \n        // Collect all the results\n        RETURN \n          collect(distinct player) as players,\n          collect(distinct event) as events,\n          collect(distinct n1) + collect(distinct n2) as entities,\n          collect(distinct r1) + collect(distinct r2) as relationships\n        ","service":"mindrune-api","timestamp":"2025-03-29 16:46:55"}
{"level":"error","message":"500 - Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer. - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:46:55"}
{"level":"error","message":"Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer.","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n        // Get all players for this account\n        MATCH (players:Player {account: $account})\n        \n        // Collect the players first\n        WITH collect(players) as allPlayers\n        \n        // Process each player separately to get their events\n        UNWIND allPlayers as currentPlayer\n        \n        // For each player, find events with various relationships in batches\n        // This avoids variable scope issues with CALL blocks\n        MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n        WITH currentPlayer, collect(events) as type1Events\n        \n        MATCH (events)-[:GAINED_BY]->(currentPlayer)\n        WITH currentPlayer, type1Events, collect(events) as type2Events\n        \n        MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n        WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n        \n        MATCH (events)-[:TARGETED]->(currentPlayer)\n        WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n        \n        MATCH (currentPlayer)-[:PERFORMED]->(events)\n        WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n        \n        MATCH (currentPlayer)-[:KILLED]->(events)\n        WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n        \n        // Combine all event types and sort by timestamp\n        WITH currentPlayer, \n             type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n        \n        // To remove duplicates more efficiently\n        WITH currentPlayer, combinedEvents as events\nUNWIND events as event\nWITH currentPlayer, event\nWHERE event IS NOT NULL\nWITH currentPlayer, collect(DISTINCT event) as uniqueEvents\n        \n        // Sort events by timestamp and take only the most recent ones\n        WITH currentPlayer, uniqueEvents\n        UNWIND uniqueEvents as event\n        WITH currentPlayer, event\n        ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n        \n        // Collect player-specific events\n        WITH currentPlayer, collect(event) as playerEvents\n        \n        // Add to our result collection of player-event pairs\n        WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n        \n        // Now process all the relationships for visualization\n        UNWIND playerData as pd\n        WITH pd.player as player, pd.events as events\n        \n        // Flatten events for relationship discovery\n        UNWIND events as event\n        \n        // Get outgoing relationships from events\n        OPTIONAL MATCH (event)-[r1]->(n1)\n        WHERE NOT type(r1) = \"PART_OF\"\n        \n        // Get incoming relationships to events\n        OPTIONAL MATCH (n2)-[r2]->(event)\n        WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n        \n        // Collect all the results\n        RETURN \n          collect(distinct player) as players,\n          collect(distinct event) as events,\n          collect(distinct n1) + collect(distinct n2) as entities,\n          collect(distinct r1) + collect(distinct r2) as relationships\n        ","service":"mindrune-api","timestamp":"2025-03-29 16:46:55"}
{"level":"error","message":"500 - Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer. - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:46:55"}
{"level":"error","message":"Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer.","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n        // Get all players for this account\n        MATCH (players:Player {account: $account})\n        \n        // Collect the players first\n        WITH collect(players) as allPlayers\n        \n        // Process each player separately to get their events\n        UNWIND allPlayers as currentPlayer\n        \n        // For each player, find events with various relationships in batches\n        // This avoids variable scope issues with CALL blocks\n        MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n        WITH currentPlayer, collect(events) as type1Events\n        \n        MATCH (events)-[:GAINED_BY]->(currentPlayer)\n        WITH currentPlayer, type1Events, collect(events) as type2Events\n        \n        MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n        WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n        \n        MATCH (events)-[:TARGETED]->(currentPlayer)\n        WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n        \n        MATCH (currentPlayer)-[:PERFORMED]->(events)\n        WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n        \n        MATCH (currentPlayer)-[:KILLED]->(events)\n        WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n        \n        // Combine all event types and sort by timestamp\n        WITH currentPlayer, \n             type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n        \n        // To remove duplicates more efficiently\n        WITH currentPlayer, combinedEvents as events\nUNWIND events as event\nWITH currentPlayer, event\nWHERE event IS NOT NULL\nWITH currentPlayer, collect(DISTINCT event) as uniqueEvents\n        \n        // Sort events by timestamp and take only the most recent ones\n        WITH currentPlayer, uniqueEvents\n        UNWIND uniqueEvents as event\n        WITH currentPlayer, event\n        ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n        \n        // Collect player-specific events\n        WITH currentPlayer, collect(event) as playerEvents\n        \n        // Add to our result collection of player-event pairs\n        WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n        \n        // Now process all the relationships for visualization\n        UNWIND playerData as pd\n        WITH pd.player as player, pd.events as events\n        \n        // Flatten events for relationship discovery\n        UNWIND events as event\n        \n        // Get outgoing relationships from events\n        OPTIONAL MATCH (event)-[r1]->(n1)\n        WHERE NOT type(r1) = \"PART_OF\"\n        \n        // Get incoming relationships to events\n        OPTIONAL MATCH (n2)-[r2]->(event)\n        WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n        \n        // Collect all the results\n        RETURN \n          collect(distinct player) as players,\n          collect(distinct event) as events,\n          collect(distinct n1) + collect(distinct n2) as entities,\n          collect(distinct r1) + collect(distinct r2) as relationships\n        ","service":"mindrune-api","timestamp":"2025-03-29 16:46:58"}
{"level":"error","message":"500 - Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer. - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:46:58"}
{"level":"error","message":"Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 27 (offset: 1586))\n\"      WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                           ^","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      // Get all players for this account\n      MATCH (players:Player {account: $account})\n      \n      // Collect the players first\n      WITH collect(players) as allPlayers\n      \n      // Process each player separately to get their events\n      UNWIND allPlayers as currentPlayer\n      \n      // For each player, find events with various relationships in batches\n      // This avoids variable scope issues with CALL blocks\n      MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n      WITH currentPlayer, collect(events) as type1Events\n      \n      MATCH (events)-[:GAINED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, collect(events) as type2Events\n      \n      MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n      \n      MATCH (events)-[:TARGETED]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n      \n      MATCH (currentPlayer)-[:PERFORMED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n      \n      MATCH (currentPlayer)-[:KILLED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n      \n      // Combine all event types and sort by timestamp\n      WITH currentPlayer, \n           type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n      \n      // To remove duplicates more efficiently\n      WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\n      \n      // Sort events by timestamp and take only the most recent ones\n      WITH currentPlayer, uniqueEvents\n      UNWIND uniqueEvents as event\n      WITH currentPlayer, event\n      ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n      \n      // Collect player-specific events\n      WITH currentPlayer, collect(event) as playerEvents\n      \n      // Add to our result collection of player-event pairs\n      WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n      \n      // Now process all the relationships for visualization\n      UNWIND playerData as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten events for relationship discovery\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      // Collect all the results\n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:48:18"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 27 (offset: 1586))\n\"      WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                           ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:48:18"}
{"level":"error","message":"Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 27 (offset: 1586))\n\"      WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                           ^","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      // Get all players for this account\n      MATCH (players:Player {account: $account})\n      \n      // Collect the players first\n      WITH collect(players) as allPlayers\n      \n      // Process each player separately to get their events\n      UNWIND allPlayers as currentPlayer\n      \n      // For each player, find events with various relationships in batches\n      // This avoids variable scope issues with CALL blocks\n      MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n      WITH currentPlayer, collect(events) as type1Events\n      \n      MATCH (events)-[:GAINED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, collect(events) as type2Events\n      \n      MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n      \n      MATCH (events)-[:TARGETED]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n      \n      MATCH (currentPlayer)-[:PERFORMED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n      \n      MATCH (currentPlayer)-[:KILLED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n      \n      // Combine all event types and sort by timestamp\n      WITH currentPlayer, \n           type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n      \n      // To remove duplicates more efficiently\n      WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\n      \n      // Sort events by timestamp and take only the most recent ones\n      WITH currentPlayer, uniqueEvents\n      UNWIND uniqueEvents as event\n      WITH currentPlayer, event\n      ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n      \n      // Collect player-specific events\n      WITH currentPlayer, collect(event) as playerEvents\n      \n      // Add to our result collection of player-event pairs\n      WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n      \n      // Now process all the relationships for visualization\n      UNWIND playerData as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten events for relationship discovery\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      // Collect all the results\n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:48:18"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 27 (offset: 1586))\n\"      WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                           ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:48:18"}
{"level":"error","message":"Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 27 (offset: 1586))\n\"      WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                           ^","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      // Get all players for this account\n      MATCH (players:Player {account: $account})\n      \n      // Collect the players first\n      WITH collect(players) as allPlayers\n      \n      // Process each player separately to get their events\n      UNWIND allPlayers as currentPlayer\n      \n      // For each player, find events with various relationships in batches\n      // This avoids variable scope issues with CALL blocks\n      MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n      WITH currentPlayer, collect(events) as type1Events\n      \n      MATCH (events)-[:GAINED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, collect(events) as type2Events\n      \n      MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n      \n      MATCH (events)-[:TARGETED]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n      \n      MATCH (currentPlayer)-[:PERFORMED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n      \n      MATCH (currentPlayer)-[:KILLED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n      \n      // Combine all event types and sort by timestamp\n      WITH currentPlayer, \n           type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n      \n      // To remove duplicates more efficiently\n      WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\n      \n      // Sort events by timestamp and take only the most recent ones\n      WITH currentPlayer, uniqueEvents\n      UNWIND uniqueEvents as event\n      WITH currentPlayer, event\n      ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n      \n      // Collect player-specific events\n      WITH currentPlayer, collect(event) as playerEvents\n      \n      // Add to our result collection of player-event pairs\n      WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n      \n      // Now process all the relationships for visualization\n      UNWIND playerData as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten events for relationship discovery\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      // Collect all the results\n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:48:20"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 27 (offset: 1586))\n\"      WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                           ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:48:20"}
{"level":"error","message":"Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer.","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      // Get all players for this account\n      MATCH (players:Player {account: $account})\n      \n      // Collect the players first\n      WITH collect(players) as allPlayers\n      \n      // Process each player separately to get their events\n      UNWIND allPlayers as currentPlayer\n      \n      // For each player, find events with various relationships in batches\n      // This avoids variable scope issues with CALL blocks\n      MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n      WITH currentPlayer, collect(events) as type1Events\n      \n      MATCH (events)-[:GAINED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, collect(events) as type2Events\n      \n      MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n      \n      MATCH (events)-[:TARGETED]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n      \n      MATCH (currentPlayer)-[:PERFORMED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n      \n      MATCH (currentPlayer)-[:KILLED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n      \n      // Combine all event types and sort by timestamp\n      WITH currentPlayer, \n           type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n      \n      // To remove duplicates more efficiently\n      WITH currentPlayer, combinedEvents as events\nUNWIND events as event\nWITH currentPlayer, event\nWHERE event IS NOT NULL\nWITH currentPlayer, collect(DISTINCT event) as uniqueEvents\n      \n      // Sort events by timestamp and take only the most recent ones\n      WITH currentPlayer, uniqueEvents\n      UNWIND uniqueEvents as event\n      WITH currentPlayer, event\n      ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n      \n      // Collect player-specific events\n      WITH currentPlayer, collect(event) as playerEvents\n      \n      // Add to our result collection of player-event pairs\n      WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n      \n      // Now process all the relationships for visualization\n      UNWIND playerData as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten events for relationship discovery\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      // Collect all the results\n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:49:03"}
{"level":"error","message":"500 - Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer. - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:49:03"}
{"level":"error","message":"Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer.","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      // Get all players for this account\n      MATCH (players:Player {account: $account})\n      \n      // Collect the players first\n      WITH collect(players) as allPlayers\n      \n      // Process each player separately to get their events\n      UNWIND allPlayers as currentPlayer\n      \n      // For each player, find events with various relationships in batches\n      // This avoids variable scope issues with CALL blocks\n      MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n      WITH currentPlayer, collect(events) as type1Events\n      \n      MATCH (events)-[:GAINED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, collect(events) as type2Events\n      \n      MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n      \n      MATCH (events)-[:TARGETED]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n      \n      MATCH (currentPlayer)-[:PERFORMED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n      \n      MATCH (currentPlayer)-[:KILLED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n      \n      // Combine all event types and sort by timestamp\n      WITH currentPlayer, \n           type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n      \n      // To remove duplicates more efficiently\n      WITH currentPlayer, combinedEvents as events\nUNWIND events as event\nWITH currentPlayer, event\nWHERE event IS NOT NULL\nWITH currentPlayer, collect(DISTINCT event) as uniqueEvents\n      \n      // Sort events by timestamp and take only the most recent ones\n      WITH currentPlayer, uniqueEvents\n      UNWIND uniqueEvents as event\n      WITH currentPlayer, event\n      ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n      \n      // Collect player-specific events\n      WITH currentPlayer, collect(event) as playerEvents\n      \n      // Add to our result collection of player-event pairs\n      WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n      \n      // Now process all the relationships for visualization\n      UNWIND playerData as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten events for relationship discovery\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      // Collect all the results\n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:49:03"}
{"level":"error","message":"500 - Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer. - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:49:03"}
{"level":"error","message":"Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer.","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      // Get all players for this account\n      MATCH (players:Player {account: $account})\n      \n      // Collect the players first\n      WITH collect(players) as allPlayers\n      \n      // Process each player separately to get their events\n      UNWIND allPlayers as currentPlayer\n      \n      // For each player, find events with various relationships in batches\n      // This avoids variable scope issues with CALL blocks\n      MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n      WITH currentPlayer, collect(events) as type1Events\n      \n      MATCH (events)-[:GAINED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, collect(events) as type2Events\n      \n      MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n      \n      MATCH (events)-[:TARGETED]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n      \n      MATCH (currentPlayer)-[:PERFORMED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n      \n      MATCH (currentPlayer)-[:KILLED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n      \n      // Combine all event types and sort by timestamp\n      WITH currentPlayer, \n           type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n      \n      // To remove duplicates more efficiently\n      WITH currentPlayer, combinedEvents as events\nUNWIND events as event\nWITH currentPlayer, event\nWHERE event IS NOT NULL\nWITH currentPlayer, collect(DISTINCT event) as uniqueEvents\n      \n      // Sort events by timestamp and take only the most recent ones\n      WITH currentPlayer, uniqueEvents\n      UNWIND uniqueEvents as event\n      WITH currentPlayer, event\n      ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n      \n      // Collect player-specific events\n      WITH currentPlayer, collect(event) as playerEvents\n      \n      // Add to our result collection of player-event pairs\n      WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n      \n      // Now process all the relationships for visualization\n      UNWIND playerData as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten events for relationship discovery\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      // Collect all the results\n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:49:06"}
{"level":"error","message":"500 - Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer. - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:49:06"}
{"level":"error","message":"Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 27 (offset: 1586))\n\"      WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                           ^","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      // Get all players for this account\n      MATCH (players:Player {account: $account})\n      \n      // Collect the players first\n      WITH collect(players) as allPlayers\n      \n      // Process each player separately to get their events\n      UNWIND allPlayers as currentPlayer\n      \n      // For each player, find events with various relationships in batches\n      // This avoids variable scope issues with CALL blocks\n      MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n      WITH currentPlayer, collect(events) as type1Events\n      \n      MATCH (events)-[:GAINED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, collect(events) as type2Events\n      \n      MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n      \n      MATCH (events)-[:TARGETED]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n      \n      MATCH (currentPlayer)-[:PERFORMED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n      \n      MATCH (currentPlayer)-[:KILLED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n      \n      // Combine all event types and sort by timestamp\n      WITH currentPlayer, \n           type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n      \n      // To remove duplicates more efficiently\n      WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\n      \n      // Sort events by timestamp and take only the most recent ones\n      WITH currentPlayer, uniqueEvents\n      UNWIND uniqueEvents as event\n      WITH currentPlayer, event\n      ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n      \n      // Collect player-specific events\n      WITH currentPlayer, collect(event) as playerEvents\n      \n      // Add to our result collection of player-event pairs\n      WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n      \n      // Now process all the relationships for visualization\n      UNWIND playerData as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten events for relationship discovery\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      // Collect all the results\n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:49:13"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 27 (offset: 1586))\n\"      WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                           ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:49:13"}
{"level":"error","message":"Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 27 (offset: 1586))\n\"      WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                           ^","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      // Get all players for this account\n      MATCH (players:Player {account: $account})\n      \n      // Collect the players first\n      WITH collect(players) as allPlayers\n      \n      // Process each player separately to get their events\n      UNWIND allPlayers as currentPlayer\n      \n      // For each player, find events with various relationships in batches\n      // This avoids variable scope issues with CALL blocks\n      MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n      WITH currentPlayer, collect(events) as type1Events\n      \n      MATCH (events)-[:GAINED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, collect(events) as type2Events\n      \n      MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n      \n      MATCH (events)-[:TARGETED]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n      \n      MATCH (currentPlayer)-[:PERFORMED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n      \n      MATCH (currentPlayer)-[:KILLED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n      \n      // Combine all event types and sort by timestamp\n      WITH currentPlayer, \n           type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n      \n      // To remove duplicates more efficiently\n      WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\n      \n      // Sort events by timestamp and take only the most recent ones\n      WITH currentPlayer, uniqueEvents\n      UNWIND uniqueEvents as event\n      WITH currentPlayer, event\n      ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n      \n      // Collect player-specific events\n      WITH currentPlayer, collect(event) as playerEvents\n      \n      // Add to our result collection of player-event pairs\n      WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n      \n      // Now process all the relationships for visualization\n      UNWIND playerData as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten events for relationship discovery\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      // Collect all the results\n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:49:13"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 27 (offset: 1586))\n\"      WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                           ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:49:13"}
{"level":"error","message":"Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 27 (offset: 1586))\n\"      WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                           ^","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      // Get all players for this account\n      MATCH (players:Player {account: $account})\n      \n      // Collect the players first\n      WITH collect(players) as allPlayers\n      \n      // Process each player separately to get their events\n      UNWIND allPlayers as currentPlayer\n      \n      // For each player, find events with various relationships in batches\n      // This avoids variable scope issues with CALL blocks\n      MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n      WITH currentPlayer, collect(events) as type1Events\n      \n      MATCH (events)-[:GAINED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, collect(events) as type2Events\n      \n      MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n      \n      MATCH (events)-[:TARGETED]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n      \n      MATCH (currentPlayer)-[:PERFORMED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n      \n      MATCH (currentPlayer)-[:KILLED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n      \n      // Combine all event types and sort by timestamp\n      WITH currentPlayer, \n           type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n      \n      // To remove duplicates more efficiently\n      WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\n      \n      // Sort events by timestamp and take only the most recent ones\n      WITH currentPlayer, uniqueEvents\n      UNWIND uniqueEvents as event\n      WITH currentPlayer, event\n      ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n      \n      // Collect player-specific events\n      WITH currentPlayer, collect(event) as playerEvents\n      \n      // Add to our result collection of player-event pairs\n      WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n      \n      // Now process all the relationships for visualization\n      UNWIND playerData as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten events for relationship discovery\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      // Collect all the results\n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:49:15"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 27 (offset: 1586))\n\"      WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                           ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:49:15"}
{"level":"error","message":"Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer.","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      // Get all players for this account\n      MATCH (players:Player {account: $account})\n      \n      // Collect the players first\n      WITH collect(players) as allPlayers\n      \n      // Process each player separately to get their events\n      UNWIND allPlayers as currentPlayer\n      \n      // For each player, find events with various relationships in batches\n      // This avoids variable scope issues with CALL blocks\n      MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n      WITH currentPlayer, collect(events) as type1Events\n      \n      MATCH (events)-[:GAINED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, collect(events) as type2Events\n      \n      MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n      \n      MATCH (events)-[:TARGETED]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n      \n      MATCH (currentPlayer)-[:PERFORMED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n      \n      MATCH (currentPlayer)-[:KILLED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n      \n      // Combine all event types and sort by timestamp\n      WITH currentPlayer, \n           type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n      \n      // To remove duplicates more efficiently (without requiring APOC)\n      WITH currentPlayer, combinedEvents as events\n      UNWIND events as event\n      WITH currentPlayer, event\n      WHERE event IS NOT NULL\n      WITH currentPlayer, collect(DISTINCT event) as uniqueEvents\n      \n      // Sort events by timestamp and take only the most recent ones\n      WITH currentPlayer, uniqueEvents\n      UNWIND uniqueEvents as event\n      WITH currentPlayer, event\n      ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n      \n      // Collect player-specific events\n      WITH currentPlayer, collect(event) as playerEvents\n      \n      // Add to our result collection of player-event pairs\n      WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n      \n      // Now process all the relationships for visualization\n      UNWIND playerData as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten events for relationship discovery\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      // Collect all the results\n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:50:14"}
{"level":"error","message":"500 - Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer. - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:50:14"}
{"level":"error","message":"Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer.","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      // Get all players for this account\n      MATCH (players:Player {account: $account})\n      \n      // Collect the players first\n      WITH collect(players) as allPlayers\n      \n      // Process each player separately to get their events\n      UNWIND allPlayers as currentPlayer\n      \n      // For each player, find events with various relationships in batches\n      // This avoids variable scope issues with CALL blocks\n      MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n      WITH currentPlayer, collect(events) as type1Events\n      \n      MATCH (events)-[:GAINED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, collect(events) as type2Events\n      \n      MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n      \n      MATCH (events)-[:TARGETED]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n      \n      MATCH (currentPlayer)-[:PERFORMED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n      \n      MATCH (currentPlayer)-[:KILLED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n      \n      // Combine all event types and sort by timestamp\n      WITH currentPlayer, \n           type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n      \n      // To remove duplicates more efficiently (without requiring APOC)\n      WITH currentPlayer, combinedEvents as events\n      UNWIND events as event\n      WITH currentPlayer, event\n      WHERE event IS NOT NULL\n      WITH currentPlayer, collect(DISTINCT event) as uniqueEvents\n      \n      // Sort events by timestamp and take only the most recent ones\n      WITH currentPlayer, uniqueEvents\n      UNWIND uniqueEvents as event\n      WITH currentPlayer, event\n      ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n      \n      // Collect player-specific events\n      WITH currentPlayer, collect(event) as playerEvents\n      \n      // Add to our result collection of player-event pairs\n      WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n      \n      // Now process all the relationships for visualization\n      UNWIND playerData as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten events for relationship discovery\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      // Collect all the results\n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:50:14"}
{"level":"error","message":"500 - Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer. - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:50:14"}
{"level":"error","message":"Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer.","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      // Get all players for this account\n      MATCH (players:Player {account: $account})\n      \n      // Collect the players first\n      WITH collect(players) as allPlayers\n      \n      // Process each player separately to get their events\n      UNWIND allPlayers as currentPlayer\n      \n      // For each player, find events with various relationships in batches\n      // This avoids variable scope issues with CALL blocks\n      MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n      WITH currentPlayer, collect(events) as type1Events\n      \n      MATCH (events)-[:GAINED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, collect(events) as type2Events\n      \n      MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n      \n      MATCH (events)-[:TARGETED]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n      \n      MATCH (currentPlayer)-[:PERFORMED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n      \n      MATCH (currentPlayer)-[:KILLED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n      \n      // Combine all event types and sort by timestamp\n      WITH currentPlayer, \n           type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n      \n      // To remove duplicates more efficiently (without requiring APOC)\n      WITH currentPlayer, combinedEvents as events\n      UNWIND events as event\n      WITH currentPlayer, event\n      WHERE event IS NOT NULL\n      WITH currentPlayer, collect(DISTINCT event) as uniqueEvents\n      \n      // Sort events by timestamp and take only the most recent ones\n      WITH currentPlayer, uniqueEvents\n      UNWIND uniqueEvents as event\n      WITH currentPlayer, event\n      ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n      \n      // Collect player-specific events\n      WITH currentPlayer, collect(event) as playerEvents\n      \n      // Add to our result collection of player-event pairs\n      WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n      \n      // Now process all the relationships for visualization\n      UNWIND playerData as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten events for relationship discovery\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      // Collect all the results\n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:50:17"}
{"level":"error","message":"500 - Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer. - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:50:17"}
{"level":"error","message":"Neo4j error: Expected parameter(s): eventsPerPlayer","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n      // Get all players for this account\n      MATCH (players:Player {account: $account})\n      \n      // Collect the players first\n      WITH collect(players) as allPlayers\n      \n      // Process each player separately to get their events\n      UNWIND allPlayers as currentPlayer\n      \n      // For each player, find events with various relationships in batches\n      // This avoids variable scope issues with CALL blocks\n      MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n      WITH currentPlayer, collect(events) as type1Events\n      \n      MATCH (events)-[:GAINED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, collect(events) as type2Events\n      \n      MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n      \n      MATCH (events)-[:TARGETED]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n      \n      MATCH (currentPlayer)-[:PERFORMED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n      \n      MATCH (currentPlayer)-[:KILLED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n      \n      // Combine all event types and sort by timestamp\n      WITH currentPlayer, \n           type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n      \n      // To remove duplicates more efficiently (without requiring APOC)\n      WITH currentPlayer, combinedEvents as events\n      UNWIND events as event\n      WITH currentPlayer, event\n      WHERE event IS NOT NULL\n      WITH currentPlayer, collect(DISTINCT event) as uniqueEvents\n      \n      // Sort events by timestamp and take only the most recent ones\n      WITH currentPlayer, uniqueEvents\n      UNWIND uniqueEvents as event\n      WITH currentPlayer, event\n      ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n      \n      // Collect player-specific events\n      WITH currentPlayer, collect(event) as playerEvents\n      \n      // Add to our result collection of player-event pairs\n      WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n      \n      // Now process all the relationships for visualization\n      UNWIND playerData as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten events for relationship discovery\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      // Collect all the results\n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:51:06"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): eventsPerPlayer - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:51:06"}
{"level":"error","message":"Neo4j error: Expected parameter(s): eventsPerPlayer","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n      // Get all players for this account\n      MATCH (players:Player {account: $account})\n      \n      // Collect the players first\n      WITH collect(players) as allPlayers\n      \n      // Process each player separately to get their events\n      UNWIND allPlayers as currentPlayer\n      \n      // For each player, find events with various relationships in batches\n      // This avoids variable scope issues with CALL blocks\n      MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n      WITH currentPlayer, collect(events) as type1Events\n      \n      MATCH (events)-[:GAINED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, collect(events) as type2Events\n      \n      MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n      \n      MATCH (events)-[:TARGETED]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n      \n      MATCH (currentPlayer)-[:PERFORMED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n      \n      MATCH (currentPlayer)-[:KILLED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n      \n      // Combine all event types and sort by timestamp\n      WITH currentPlayer, \n           type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n      \n      // To remove duplicates more efficiently (without requiring APOC)\n      WITH currentPlayer, combinedEvents as events\n      UNWIND events as event\n      WITH currentPlayer, event\n      WHERE event IS NOT NULL\n      WITH currentPlayer, collect(DISTINCT event) as uniqueEvents\n      \n      // Sort events by timestamp and take only the most recent ones\n      WITH currentPlayer, uniqueEvents\n      UNWIND uniqueEvents as event\n      WITH currentPlayer, event\n      ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n      \n      // Collect player-specific events\n      WITH currentPlayer, collect(event) as playerEvents\n      \n      // Add to our result collection of player-event pairs\n      WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n      \n      // Now process all the relationships for visualization\n      UNWIND playerData as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten events for relationship discovery\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      // Collect all the results\n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 16:51:06"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): eventsPerPlayer - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 16:51:06"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 18:24:55"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 18:24:55"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 18:24:57"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 18:24:57"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 18:25:00"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 18:25:00"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 18:25:04"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 18:25:04"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 18:25:07"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 18:25:07"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 21:32:44"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 21:32:44"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 21:34:04"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 21:34:04"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-29 21:34:06"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 21:34:06"}
{"level":"error","message":"Neo4j error: Invalid input 'OR': expected a graph pattern, 'FOREACH', ',', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'USING', 'WHERE', 'WITH' or <EOF> (line 12, column 1 (offset: 382))\n\"OR (players)-[:PERFORMED|KILLED]->(events)\"\n ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n// Get all players for this account\nMATCH (players:Player {account: $account})\n\n// Process each player separately with a reasonable event limit\nWITH players\nORDER BY players.name\nLIMIT 10  // Prevent too many players overloading the visualization\n\n// For each player, get their events with proper separation\nMATCH (events)-[:PERFORMED_BY|GAINED_BY|RECEIVED_BY|TARGETED]->(players)\nOR (players)-[:PERFORMED|KILLED]->(events)\n\n// Sort by timestamp and limit per player for better performance\nWITH players, events\nORDER BY events.timestamp DESC\nLIMIT 75  // Reduced limit per player to improve performance\n\n// Collect events per player\nWITH players, collect(events) as playerEvents\n\n// Get node connections for visualization with proper player attribution\nUNWIND playerEvents as event\n\n// Get direct outgoing relationships from events\nOPTIONAL MATCH (event)-[r1]->(n1)\nWHERE NOT type(r1) = \"PART_OF\"\n\n// Get direct incoming relationships to events\nOPTIONAL MATCH (n2)-[r2]->(event)\nWHERE NOT (n2:Player OR n2 = players)\n\n// Collect all nodes and relationships\nWITH collect(DISTINCT players) as allPlayers,\n     collect(DISTINCT event) as allEvents,\n     collect(DISTINCT n1) as outNodes,\n     collect(DISTINCT n2) as inNodes, \n     collect(DISTINCT r1) as outRels,\n     collect(DISTINCT r2) as inRels\n\n// Return the final combined data\nRETURN\n  allPlayers as players,\n  allEvents as events,\n  outNodes + inNodes as entities,\n  outRels + inRels as relationships\n","service":"mindrune-api","timestamp":"2025-03-29 21:57:22"}
{"level":"error","message":"500 - Neo4j error: Invalid input 'OR': expected a graph pattern, 'FOREACH', ',', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'USING', 'WHERE', 'WITH' or <EOF> (line 12, column 1 (offset: 382))\n\"OR (players)-[:PERFORMED|KILLED]->(events)\"\n ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 21:57:22"}
{"level":"error","message":"Neo4j error: Invalid input 'OR': expected a graph pattern, 'FOREACH', ',', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'USING', 'WHERE', 'WITH' or <EOF> (line 12, column 1 (offset: 382))\n\"OR (players)-[:PERFORMED|KILLED]->(events)\"\n ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n// Get all players for this account\nMATCH (players:Player {account: $account})\n\n// Process each player separately with a reasonable event limit\nWITH players\nORDER BY players.name\nLIMIT 10  // Prevent too many players overloading the visualization\n\n// For each player, get their events with proper separation\nMATCH (events)-[:PERFORMED_BY|GAINED_BY|RECEIVED_BY|TARGETED]->(players)\nOR (players)-[:PERFORMED|KILLED]->(events)\n\n// Sort by timestamp and limit per player for better performance\nWITH players, events\nORDER BY events.timestamp DESC\nLIMIT 75  // Reduced limit per player to improve performance\n\n// Collect events per player\nWITH players, collect(events) as playerEvents\n\n// Get node connections for visualization with proper player attribution\nUNWIND playerEvents as event\n\n// Get direct outgoing relationships from events\nOPTIONAL MATCH (event)-[r1]->(n1)\nWHERE NOT type(r1) = \"PART_OF\"\n\n// Get direct incoming relationships to events\nOPTIONAL MATCH (n2)-[r2]->(event)\nWHERE NOT (n2:Player OR n2 = players)\n\n// Collect all nodes and relationships\nWITH collect(DISTINCT players) as allPlayers,\n     collect(DISTINCT event) as allEvents,\n     collect(DISTINCT n1) as outNodes,\n     collect(DISTINCT n2) as inNodes, \n     collect(DISTINCT r1) as outRels,\n     collect(DISTINCT r2) as inRels\n\n// Return the final combined data\nRETURN\n  allPlayers as players,\n  allEvents as events,\n  outNodes + inNodes as entities,\n  outRels + inRels as relationships\n","service":"mindrune-api","timestamp":"2025-03-29 21:57:22"}
{"level":"error","message":"500 - Neo4j error: Invalid input 'OR': expected a graph pattern, 'FOREACH', ',', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'USING', 'WHERE', 'WITH' or <EOF> (line 12, column 1 (offset: 382))\n\"OR (players)-[:PERFORMED|KILLED]->(events)\"\n ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 21:57:22"}
{"level":"error","message":"Neo4j error: Invalid input 'OR': expected a graph pattern, 'FOREACH', ',', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'USING', 'WHERE', 'WITH' or <EOF> (line 12, column 1 (offset: 382))\n\"OR (players)-[:PERFORMED|KILLED]->(events)\"\n ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n// Get all players for this account\nMATCH (players:Player {account: $account})\n\n// Process each player separately with a reasonable event limit\nWITH players\nORDER BY players.name\nLIMIT 10  // Prevent too many players overloading the visualization\n\n// For each player, get their events with proper separation\nMATCH (events)-[:PERFORMED_BY|GAINED_BY|RECEIVED_BY|TARGETED]->(players)\nOR (players)-[:PERFORMED|KILLED]->(events)\n\n// Sort by timestamp and limit per player for better performance\nWITH players, events\nORDER BY events.timestamp DESC\nLIMIT 75  // Reduced limit per player to improve performance\n\n// Collect events per player\nWITH players, collect(events) as playerEvents\n\n// Get node connections for visualization with proper player attribution\nUNWIND playerEvents as event\n\n// Get direct outgoing relationships from events\nOPTIONAL MATCH (event)-[r1]->(n1)\nWHERE NOT type(r1) = \"PART_OF\"\n\n// Get direct incoming relationships to events\nOPTIONAL MATCH (n2)-[r2]->(event)\nWHERE NOT (n2:Player OR n2 = players)\n\n// Collect all nodes and relationships\nWITH collect(DISTINCT players) as allPlayers,\n     collect(DISTINCT event) as allEvents,\n     collect(DISTINCT n1) as outNodes,\n     collect(DISTINCT n2) as inNodes, \n     collect(DISTINCT r1) as outRels,\n     collect(DISTINCT r2) as inRels\n\n// Return the final combined data\nRETURN\n  allPlayers as players,\n  allEvents as events,\n  outNodes + inNodes as entities,\n  outRels + inRels as relationships\n","service":"mindrune-api","timestamp":"2025-03-29 21:57:27"}
{"level":"error","message":"500 - Neo4j error: Invalid input 'OR': expected a graph pattern, 'FOREACH', ',', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'USING', 'WHERE', 'WITH' or <EOF> (line 12, column 1 (offset: 382))\n\"OR (players)-[:PERFORMED|KILLED]->(events)\"\n ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 21:57:27"}
{"level":"error","message":"Neo4j error: Variable `players` already declared in outer scope (line 15, column 10 (offset: 450))\n\"  RETURN players, events\"\n          ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n// Get all players for this account\nMATCH (players:Player {account: $account})\n\n// Process each player separately with a reasonable event limit\nWITH players\nORDER BY players.name\nLIMIT 10  // Prevent too many players overloading the visualization\n\n// For each player, get their events with proper separation using UNION\nCALL {\n  WITH players\n  // Get incoming events (where player is the target)\n  MATCH (events)-[:PERFORMED_BY]->(players)\n  RETURN players, events\n  UNION\n  WITH players\n  MATCH (events)-[:GAINED_BY]->(players)\n  RETURN players, events\n  UNION\n  WITH players\n  MATCH (events)-[:RECEIVED_BY]->(players)\n  RETURN players, events\n  UNION\n  WITH players\n  MATCH (events)-[:TARGETED]->(players)\n  RETURN players, events\n  UNION\n  WITH players\n  // Get outgoing events (where player is the source)\n  MATCH (players)-[:PERFORMED]->(events)\n  RETURN players, events\n  UNION\n  WITH players\n  MATCH (players)-[:KILLED]->(events)\n  RETURN players, events\n}\n\n// Sort by timestamp and limit per player for better performance\nWITH players, events\nORDER BY events.timestamp DESC\nLIMIT 75  // Reduced limit per player to improve performance\n\n// Collect events per player\nWITH players, collect(events) as playerEvents\n\n// Get node connections for visualization with proper player attribution\nUNWIND playerEvents as event\n\n// Get direct outgoing relationships from events\nOPTIONAL MATCH (event)-[r1]->(n1)\nWHERE NOT type(r1) = \"PART_OF\"\n\n// Get direct incoming relationships to events\nOPTIONAL MATCH (n2)-[r2]->(event)\nWHERE NOT (n2:Player OR n2 = players)\n\n// Collect all nodes and relationships\nWITH collect(DISTINCT players) as allPlayers,\n     collect(DISTINCT event) as allEvents,\n     collect(DISTINCT n1) as outNodes,\n     collect(DISTINCT n2) as inNodes, \n     collect(DISTINCT r1) as outRels,\n     collect(DISTINCT r2) as inRels\n\n// Return the final combined data\nRETURN\n  allPlayers as players,\n  allEvents as events,\n  outNodes + inNodes as entities,\n  outRels + inRels as relationships\n","service":"mindrune-api","timestamp":"2025-03-29 21:58:25"}
{"level":"error","message":"500 - Neo4j error: Variable `players` already declared in outer scope (line 15, column 10 (offset: 450))\n\"  RETURN players, events\"\n          ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 21:58:25"}
{"level":"error","message":"Neo4j error: Variable `players` already declared in outer scope (line 15, column 10 (offset: 450))\n\"  RETURN players, events\"\n          ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n// Get all players for this account\nMATCH (players:Player {account: $account})\n\n// Process each player separately with a reasonable event limit\nWITH players\nORDER BY players.name\nLIMIT 10  // Prevent too many players overloading the visualization\n\n// For each player, get their events with proper separation using UNION\nCALL {\n  WITH players\n  // Get incoming events (where player is the target)\n  MATCH (events)-[:PERFORMED_BY]->(players)\n  RETURN players, events\n  UNION\n  WITH players\n  MATCH (events)-[:GAINED_BY]->(players)\n  RETURN players, events\n  UNION\n  WITH players\n  MATCH (events)-[:RECEIVED_BY]->(players)\n  RETURN players, events\n  UNION\n  WITH players\n  MATCH (events)-[:TARGETED]->(players)\n  RETURN players, events\n  UNION\n  WITH players\n  // Get outgoing events (where player is the source)\n  MATCH (players)-[:PERFORMED]->(events)\n  RETURN players, events\n  UNION\n  WITH players\n  MATCH (players)-[:KILLED]->(events)\n  RETURN players, events\n}\n\n// Sort by timestamp and limit per player for better performance\nWITH players, events\nORDER BY events.timestamp DESC\nLIMIT 75  // Reduced limit per player to improve performance\n\n// Collect events per player\nWITH players, collect(events) as playerEvents\n\n// Get node connections for visualization with proper player attribution\nUNWIND playerEvents as event\n\n// Get direct outgoing relationships from events\nOPTIONAL MATCH (event)-[r1]->(n1)\nWHERE NOT type(r1) = \"PART_OF\"\n\n// Get direct incoming relationships to events\nOPTIONAL MATCH (n2)-[r2]->(event)\nWHERE NOT (n2:Player OR n2 = players)\n\n// Collect all nodes and relationships\nWITH collect(DISTINCT players) as allPlayers,\n     collect(DISTINCT event) as allEvents,\n     collect(DISTINCT n1) as outNodes,\n     collect(DISTINCT n2) as inNodes, \n     collect(DISTINCT r1) as outRels,\n     collect(DISTINCT r2) as inRels\n\n// Return the final combined data\nRETURN\n  allPlayers as players,\n  allEvents as events,\n  outNodes + inNodes as entities,\n  outRels + inRels as relationships\n","service":"mindrune-api","timestamp":"2025-03-29 21:58:25"}
{"level":"error","message":"500 - Neo4j error: Variable `players` already declared in outer scope (line 15, column 10 (offset: 450))\n\"  RETURN players, events\"\n          ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 21:58:25"}
{"level":"error","message":"Neo4j error: Variable `players` already declared in outer scope (line 15, column 10 (offset: 450))\n\"  RETURN players, events\"\n          ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n// Get all players for this account\nMATCH (players:Player {account: $account})\n\n// Process each player separately with a reasonable event limit\nWITH players\nORDER BY players.name\nLIMIT 10  // Prevent too many players overloading the visualization\n\n// For each player, get their events with proper separation using UNION\nCALL {\n  WITH players\n  // Get incoming events (where player is the target)\n  MATCH (events)-[:PERFORMED_BY]->(players)\n  RETURN players, events\n  UNION\n  WITH players\n  MATCH (events)-[:GAINED_BY]->(players)\n  RETURN players, events\n  UNION\n  WITH players\n  MATCH (events)-[:RECEIVED_BY]->(players)\n  RETURN players, events\n  UNION\n  WITH players\n  MATCH (events)-[:TARGETED]->(players)\n  RETURN players, events\n  UNION\n  WITH players\n  // Get outgoing events (where player is the source)\n  MATCH (players)-[:PERFORMED]->(events)\n  RETURN players, events\n  UNION\n  WITH players\n  MATCH (players)-[:KILLED]->(events)\n  RETURN players, events\n}\n\n// Sort by timestamp and limit per player for better performance\nWITH players, events\nORDER BY events.timestamp DESC\nLIMIT 75  // Reduced limit per player to improve performance\n\n// Collect events per player\nWITH players, collect(events) as playerEvents\n\n// Get node connections for visualization with proper player attribution\nUNWIND playerEvents as event\n\n// Get direct outgoing relationships from events\nOPTIONAL MATCH (event)-[r1]->(n1)\nWHERE NOT type(r1) = \"PART_OF\"\n\n// Get direct incoming relationships to events\nOPTIONAL MATCH (n2)-[r2]->(event)\nWHERE NOT (n2:Player OR n2 = players)\n\n// Collect all nodes and relationships\nWITH collect(DISTINCT players) as allPlayers,\n     collect(DISTINCT event) as allEvents,\n     collect(DISTINCT n1) as outNodes,\n     collect(DISTINCT n2) as inNodes, \n     collect(DISTINCT r1) as outRels,\n     collect(DISTINCT r2) as inRels\n\n// Return the final combined data\nRETURN\n  allPlayers as players,\n  allEvents as events,\n  outNodes + inNodes as entities,\n  outRels + inRels as relationships\n","service":"mindrune-api","timestamp":"2025-03-29 21:58:28"}
{"level":"error","message":"500 - Neo4j error: Variable `players` already declared in outer scope (line 15, column 10 (offset: 450))\n\"  RETURN players, events\"\n          ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 21:58:28"}
{"level":"error","message":"Neo4j error: Variable `players` already declared in outer scope (line 15, column 10 (offset: 450))\n\"  RETURN players, events\"\n          ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n// Get all players for this account\nMATCH (players:Player {account: $account})\n\n// Process each player separately with a reasonable event limit\nWITH players\nORDER BY players.name\nLIMIT 10  // Prevent too many players overloading the visualization\n\n// For each player, get their events with proper separation using UNION\nCALL {\n  WITH players\n  // Get incoming events (where player is the target)\n  MATCH (events)-[:PERFORMED_BY]->(players)\n  RETURN players, events\n  UNION\n  WITH players\n  MATCH (events)-[:GAINED_BY]->(players)\n  RETURN players, events\n  UNION\n  WITH players\n  MATCH (events)-[:RECEIVED_BY]->(players)\n  RETURN players, events\n  UNION\n  WITH players\n  MATCH (events)-[:TARGETED]->(players)\n  RETURN players, events\n  UNION\n  WITH players\n  // Get outgoing events (where player is the source)\n  MATCH (players)-[:PERFORMED]->(events)\n  RETURN players, events\n  UNION\n  WITH players\n  MATCH (players)-[:KILLED]->(events)\n  RETURN players, events\n}\n\n// Sort by timestamp and limit per player for better performance\nWITH players, events\nORDER BY events.timestamp DESC\nLIMIT 75  // Reduced limit per player to improve performance\n\n// Collect events per player\nWITH players, collect(events) as playerEvents\n\n// Get node connections for visualization with proper player attribution\nUNWIND playerEvents as event\n\n// Get direct outgoing relationships from events\nOPTIONAL MATCH (event)-[r1]->(n1)\nWHERE NOT type(r1) = \"PART_OF\"\n\n// Get direct incoming relationships to events\nOPTIONAL MATCH (n2)-[r2]->(event)\nWHERE NOT (n2:Player OR n2 = players)\n\n// Collect all nodes and relationships\nWITH collect(DISTINCT players) as allPlayers,\n     collect(DISTINCT event) as allEvents,\n     collect(DISTINCT n1) as outNodes,\n     collect(DISTINCT n2) as inNodes, \n     collect(DISTINCT r1) as outRels,\n     collect(DISTINCT r2) as inRels\n\n// Return the final combined data\nRETURN\n  allPlayers as players,\n  allEvents as events,\n  outNodes + inNodes as entities,\n  outRels + inRels as relationships\n","service":"mindrune-api","timestamp":"2025-03-29 22:05:21"}
{"level":"error","message":"500 - Neo4j error: Variable `players` already declared in outer scope (line 15, column 10 (offset: 450))\n\"  RETURN players, events\"\n          ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-29 22:05:21"}
{"level":"error","message":"500 - Cannot read properties of undefined (reading 'toString') - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 07:30:10"}
{"level":"error","message":"500 - Cannot read properties of undefined (reading 'toString') - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 07:30:10"}
{"level":"error","message":"500 - Cannot read properties of undefined (reading 'toString') - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 07:30:14"}
{"level":"error","message":"500 - Cannot read properties of undefined (reading 'toString') - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 07:30:20"}
{"level":"error","message":"500 - Query must include $account parameter for security - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 09:40:04"}
{"level":"error","message":"500 - Query must include $account parameter for security - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 09:40:04"}
{"level":"error","message":"500 - Query must include $account parameter for security - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 09:40:09"}
{"level":"error","message":"500 - Cannot read properties of undefined (reading 'toString') - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:01:56"}
{"level":"error","message":"500 - Cannot read properties of undefined (reading 'toString') - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:01:56"}
{"level":"error","message":"500 - Cannot read properties of undefined (reading 'toString') - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:02:00"}
{"level":"error","message":"500 - Cannot read properties of undefined (reading 'toString') - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:02:02"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:04:08"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:04:08"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:04:08"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:04:08"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:04:13"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:04:13"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:04:21"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:04:21"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:04:21"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:04:21"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:04:24"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:04:24"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:04:26"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:04:26"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:06:24"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:06:24"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:06:26"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:06:26"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:08:59"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:08:59"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:09:00"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:09:00"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:21:33"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:21:33"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:21:33"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:21:33"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:21:38"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:21:38"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:21:39"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:21:39"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:22:02"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:22:02"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:22:02"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:22:02"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:22:06"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:22:06"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2203))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","eventLimit":2000,"playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT toInteger($eventLimit)\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:22:13"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2203))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:22:13"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2203))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","eventLimit":2000,"playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT toInteger($eventLimit)\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:22:13"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2203))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:22:13"}
{"level":"error","message":"Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer.","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n      // Get all players for this account\n      MATCH (players:Player {account: $account})\n      \n      // Collect the players first\n      WITH collect(players) as allPlayers\n      \n      // Process each player separately to get their events\n      UNWIND allPlayers as currentPlayer\n      \n      // For each player, find events with various relationships in batches\n      // This avoids variable scope issues with CALL blocks\n      MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n      WITH currentPlayer, collect(events) as type1Events\n      \n      MATCH (events)-[:GAINED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, collect(events) as type2Events\n      \n      MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n      \n      MATCH (events)-[:TARGETED]->(currentPlayer)\n      WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n      \n      MATCH (currentPlayer)-[:PERFORMED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n      \n      MATCH (currentPlayer)-[:KILLED]->(events)\n      WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n      \n      // Combine all event types and sort by timestamp\n      WITH currentPlayer, \n           type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n      \n      // To remove duplicates more efficiently (without requiring APOC)\n      WITH currentPlayer, combinedEvents as events\n      UNWIND events as event\n      WITH currentPlayer, event\n      WHERE event IS NOT NULL\n      WITH currentPlayer, collect(DISTINCT event) as uniqueEvents\n      \n      // Sort events by timestamp and take only the most recent ones\n      WITH currentPlayer, uniqueEvents\n      UNWIND uniqueEvents as event\n      WITH currentPlayer, event\n      ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n      \n      // Collect player-specific events\n      WITH currentPlayer, collect(event) as playerEvents\n      \n      // Add to our result collection of player-event pairs\n      WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n      \n      // Now process all the relationships for visualization\n      UNWIND playerData as pd\n      WITH pd.player as player, pd.events as events\n      \n      // Flatten events for relationship discovery\n      UNWIND events as event\n      \n      // Get outgoing relationships from events\n      OPTIONAL MATCH (event)-[r1]->(n1)\n      WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get incoming relationships to events\n      OPTIONAL MATCH (n2)-[r2]->(event)\n      WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n      \n      // Collect all the results\n      RETURN \n        collect(distinct player) as players,\n        collect(distinct event) as events,\n        collect(distinct n1) + collect(distinct n2) as entities,\n        collect(distinct r1) + collect(distinct r2) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:22:14"}
{"level":"error","message":"500 - Neo4j error: LIMIT: Invalid input. '300.0' is not a valid value. Must be a non-negative integer. - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:22:14"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2203))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","eventLimit":2000,"playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT toInteger($eventLimit)\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:22:16"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2203))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:22:16"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 11 (offset: 2310))\n\"          outNodes + inNodes + collect(distinct n3) as entities,\"\n           ^","params":{"account":"oauth2|discord|177946696251211776","eventLimit":2000,"playerId":8635364660489471000},"query":"\n        // Start with the player node\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n        CALL {\n          // Match events directly related to this player with all relevant relationships\n          // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n          MATCH (e)-[:PERFORMED_BY]->(p) \n          RETURN e\n          UNION\n          MATCH (e)-[:GAINED_BY]->(p) \n          RETURN e\n          UNION\n          MATCH (e)-[:RECEIVED_BY]->(p) \n          RETURN e\n          UNION\n          MATCH (e)-[:TARGETED]->(p) \n          RETURN e\n          UNION\n          MATCH (p)-[:PERFORMED]->(e) \n          RETURN e\n          UNION\n          MATCH (p)-[:KILLED]->(e) \n          RETURN e\n        }\n        \n        // Apply ordering and limit at this stage to reduce the working set\n        WITH p, e ORDER BY e.timestamp DESC LIMIT $eventLimit\n        \n        // Collect all the events first\n        WITH p, collect(e) as events\n        \n        // For each event, get its direct connections (avoiding PART_OF relationships)\n        UNWIND events as event\n        \n        // Get direct relationships from events in a more efficient way\n        OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n        \n        // Get direct relationships to events in a more efficient way\n        OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n        \n        // Only collect entities and relationships once all events are processed\n        WITH p, events, \n             collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n             collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n        \n        // Use secondary match only for the key relationships instead of all entities\n        // This saves a lot of processing time by being more selective\n        WITH p, events, outRels, outNodes, inRels, inNodes\n        \n        // Get secondary relationships between the most important entities only\n        UNWIND outNodes as n1\n        OPTIONAL MATCH (n1)-[r3]->(n3)\n        WHERE n3 <> n1 AND NOT n3 IN events\n        \n        RETURN \n          collect(distinct p) as players,\n          events,\n          outNodes + inNodes + collect(distinct n3) as entities,\n          outRels + inRels + collect(distinct r3) as relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 10:22:24"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 11 (offset: 2310))\n\"          outNodes + inNodes + collect(distinct n3) as entities,\"\n           ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:22:24"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 11 (offset: 2310))\n\"          outNodes + inNodes + collect(distinct n3) as entities,\"\n           ^","params":{"account":"oauth2|discord|177946696251211776","eventLimit":2000,"playerId":8635364660489471000},"query":"\n        // Start with the player node\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n        CALL {\n          // Match events directly related to this player with all relevant relationships\n          // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n          MATCH (e)-[:PERFORMED_BY]->(p) \n          RETURN e\n          UNION\n          MATCH (e)-[:GAINED_BY]->(p) \n          RETURN e\n          UNION\n          MATCH (e)-[:RECEIVED_BY]->(p) \n          RETURN e\n          UNION\n          MATCH (e)-[:TARGETED]->(p) \n          RETURN e\n          UNION\n          MATCH (p)-[:PERFORMED]->(e) \n          RETURN e\n          UNION\n          MATCH (p)-[:KILLED]->(e) \n          RETURN e\n        }\n        \n        // Apply ordering and limit at this stage to reduce the working set\n        WITH p, e ORDER BY e.timestamp DESC LIMIT $eventLimit\n        \n        // Collect all the events first\n        WITH p, collect(e) as events\n        \n        // For each event, get its direct connections (avoiding PART_OF relationships)\n        UNWIND events as event\n        \n        // Get direct relationships from events in a more efficient way\n        OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n        \n        // Get direct relationships to events in a more efficient way\n        OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n        \n        // Only collect entities and relationships once all events are processed\n        WITH p, events, \n             collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n             collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n        \n        // Use secondary match only for the key relationships instead of all entities\n        // This saves a lot of processing time by being more selective\n        WITH p, events, outRels, outNodes, inRels, inNodes\n        \n        // Get secondary relationships between the most important entities only\n        UNWIND outNodes as n1\n        OPTIONAL MATCH (n1)-[r3]->(n3)\n        WHERE n3 <> n1 AND NOT n3 IN events\n        \n        RETURN \n          collect(distinct p) as players,\n          events,\n          outNodes + inNodes + collect(distinct n3) as entities,\n          outRels + inRels + collect(distinct r3) as relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 10:22:24"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 11 (offset: 2310))\n\"          outNodes + inNodes + collect(distinct n3) as entities,\"\n           ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:22:24"}
{"level":"error","message":"Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 29 (offset: 1656))\n\"        WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                             ^","params":{"account":"oauth2|discord|177946696251211776","eventsPerPlayer":300},"query":"\n        // Get all players for this account\n        MATCH (players:Player {account: $account})\n        \n        // Collect the players first\n        WITH collect(players) as allPlayers\n        \n        // Process each player separately to get their events\n        UNWIND allPlayers as currentPlayer\n        \n        // For each player, find events with various relationships in batches\n        // This avoids variable scope issues with CALL blocks\n        MATCH (events)-[:PERFORMED_BY]->(currentPlayer)\n        WITH currentPlayer, collect(events) as type1Events\n        \n        MATCH (events)-[:GAINED_BY]->(currentPlayer)\n        WITH currentPlayer, type1Events, collect(events) as type2Events\n        \n        MATCH (events)-[:RECEIVED_BY]->(currentPlayer)\n        WITH currentPlayer, type1Events, type2Events, collect(events) as type3Events\n        \n        MATCH (events)-[:TARGETED]->(currentPlayer)\n        WITH currentPlayer, type1Events, type2Events, type3Events, collect(events) as type4Events\n        \n        MATCH (currentPlayer)-[:PERFORMED]->(events)\n        WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, collect(events) as type5Events\n        \n        MATCH (currentPlayer)-[:KILLED]->(events)\n        WITH currentPlayer, type1Events, type2Events, type3Events, type4Events, type5Events, collect(events) as type6Events\n        \n        // Combine all event types and sort by timestamp\n        WITH currentPlayer, \n             type1Events + type2Events + type3Events + type4Events + type5Events + type6Events as combinedEvents\n        \n        // To remove duplicates more efficiently\n        WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\n        \n        // Sort events by timestamp and take only the most recent ones\n        WITH currentPlayer, uniqueEvents\n        UNWIND uniqueEvents as event\n        WITH currentPlayer, event\n        ORDER BY event.timestamp DESC LIMIT $eventsPerPlayer\n        \n        // Collect player-specific events\n        WITH currentPlayer, collect(event) as playerEvents\n        \n        // Add to our result collection of player-event pairs\n        WITH collect({player: currentPlayer, events: playerEvents}) as playerData\n        \n        // Now process all the relationships for visualization\n        UNWIND playerData as pd\n        WITH pd.player as player, pd.events as events\n        \n        // Flatten events for relationship discovery\n        UNWIND events as event\n        \n        // Get outgoing relationships from events\n        OPTIONAL MATCH (event)-[r1]->(n1)\n        WHERE NOT type(r1) = \"PART_OF\"\n        \n        // Get incoming relationships to events\n        OPTIONAL MATCH (n2)-[r2]->(event)\n        WHERE NOT (n2:Player AND n2.playerId = player.playerId)\n        \n        // Collect all the results\n        RETURN \n          collect(distinct player) as players,\n          collect(distinct event) as events,\n          collect(distinct n1) + collect(distinct n2) as entities,\n          collect(distinct r1) + collect(distinct r2) as relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 10:22:26"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'apoc.coll.toSet' (line 36, column 29 (offset: 1656))\n\"        WITH currentPlayer, apoc.coll.toSet(combinedEvents) as uniqueEvents\"\n                             ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:22:26"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 11 (offset: 2310))\n\"          outNodes + inNodes + collect(distinct n3) as entities,\"\n           ^","params":{"account":"oauth2|discord|177946696251211776","eventLimit":2000,"playerId":8635364660489471000},"query":"\n        // Start with the player node\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n        CALL {\n          // Match events directly related to this player with all relevant relationships\n          // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n          MATCH (e)-[:PERFORMED_BY]->(p) \n          RETURN e\n          UNION\n          MATCH (e)-[:GAINED_BY]->(p) \n          RETURN e\n          UNION\n          MATCH (e)-[:RECEIVED_BY]->(p) \n          RETURN e\n          UNION\n          MATCH (e)-[:TARGETED]->(p) \n          RETURN e\n          UNION\n          MATCH (p)-[:PERFORMED]->(e) \n          RETURN e\n          UNION\n          MATCH (p)-[:KILLED]->(e) \n          RETURN e\n        }\n        \n        // Apply ordering and limit at this stage to reduce the working set\n        WITH p, e ORDER BY e.timestamp DESC LIMIT $eventLimit\n        \n        // Collect all the events first\n        WITH p, collect(e) as events\n        \n        // For each event, get its direct connections (avoiding PART_OF relationships)\n        UNWIND events as event\n        \n        // Get direct relationships from events in a more efficient way\n        OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n        \n        // Get direct relationships to events in a more efficient way\n        OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n        \n        // Only collect entities and relationships once all events are processed\n        WITH p, events, \n             collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n             collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n        \n        // Use secondary match only for the key relationships instead of all entities\n        // This saves a lot of processing time by being more selective\n        WITH p, events, outRels, outNodes, inRels, inNodes\n        \n        // Get secondary relationships between the most important entities only\n        UNWIND outNodes as n1\n        OPTIONAL MATCH (n1)-[r3]->(n3)\n        WHERE n3 <> n1 AND NOT n3 IN events\n        \n        RETURN \n          collect(distinct p) as players,\n          events,\n          outNodes + inNodes + collect(distinct n3) as entities,\n          outRels + inRels + collect(distinct r3) as relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 10:22:27"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 11 (offset: 2310))\n\"          outNodes + inNodes + collect(distinct n3) as entities,\"\n           ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:22:27"}
{"level":"error","message":"Neo4j error: Query cannot conclude with MATCH (must be a RETURN clause, a FINISH clause, an update clause, a unit subquery call, or a procedure call with no YIELD). (line 3, column 1 (offset: 31))\n\"MATCH (p:Player {account: $account, playerId: $playerId})\"\n ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n// Start with the player node\nMATCH (p:Player {account: $account, playerId: $playerId})\n// Rest of your single-player query...\n","service":"mindrune-api","timestamp":"2025-03-30 10:25:20"}
{"level":"error","message":"500 - Neo4j error: Query cannot conclude with MATCH (must be a RETURN clause, a FINISH clause, an update clause, a unit subquery call, or a procedure call with no YIELD). (line 3, column 1 (offset: 31))\n\"MATCH (p:Player {account: $account, playerId: $playerId})\"\n ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:25:20"}
{"level":"error","message":"Neo4j error: Query cannot conclude with MATCH (must be a RETURN clause, a FINISH clause, an update clause, a unit subquery call, or a procedure call with no YIELD). (line 3, column 1 (offset: 31))\n\"MATCH (p:Player {account: $account, playerId: $playerId})\"\n ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n// Start with the player node\nMATCH (p:Player {account: $account, playerId: $playerId})\n// Rest of your single-player query...\n","service":"mindrune-api","timestamp":"2025-03-30 10:25:20"}
{"level":"error","message":"500 - Neo4j error: Query cannot conclude with MATCH (must be a RETURN clause, a FINISH clause, an update clause, a unit subquery call, or a procedure call with no YIELD). (line 3, column 1 (offset: 31))\n\"MATCH (p:Player {account: $account, playerId: $playerId})\"\n ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:25:20"}
{"level":"error","message":"Neo4j error: Query cannot conclude with MATCH (must be a RETURN clause, a FINISH clause, an update clause, a unit subquery call, or a procedure call with no YIELD). (line 3, column 1 (offset: 31))\n\"MATCH (p:Player {account: $account, playerId: $playerId})\"\n ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n// Start with the player node\nMATCH (p:Player {account: $account, playerId: $playerId})\n// Rest of your single-player query...\n","service":"mindrune-api","timestamp":"2025-03-30 10:25:26"}
{"level":"error","message":"500 - Neo4j error: Query cannot conclude with MATCH (must be a RETURN clause, a FINISH clause, an update clause, a unit subquery call, or a procedure call with no YIELD). (line 3, column 1 (offset: 31))\n\"MATCH (p:Player {account: $account, playerId: $playerId})\"\n ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:25:26"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:38:01"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:38:01"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n      // Start with the player node\n      MATCH (p:Player {account: $account, playerId: $playerId})\n      \n      // Use CALL {} IN TRANSACTIONS for better memory management with large result sets\n      CALL {\n        // Match events directly related to this player with all relevant relationships\n        // Use UNION for better optimization instead of multiple OPTIONAL MATCH\n        MATCH (e)-[:PERFORMED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:GAINED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:RECEIVED_BY]->(p) \n        RETURN e\n        UNION\n        MATCH (e)-[:TARGETED]->(p) \n        RETURN e\n        UNION\n        MATCH (p)-[:PERFORMED]->(e) \n        RETURN e\n        UNION\n        MATCH (p)-[:KILLED]->(e) \n        RETURN e\n      }\n      \n      // Apply ordering and limit at this stage to reduce the working set\n      WITH p, e ORDER BY e.timestamp DESC LIMIT 2000\n      \n      // Collect all the events first\n      WITH p, collect(e) as events\n      \n      // For each event, get its direct connections (avoiding PART_OF relationships)\n      UNWIND events as event\n      \n      // Get direct relationships from events in a more efficient way\n      OPTIONAL MATCH (event)-[r1]->(n1) WHERE NOT type(r1) = \"PART_OF\"\n      \n      // Get direct relationships to events in a more efficient way\n      OPTIONAL MATCH (n2)-[r2]->(event) WHERE NOT (n2:Player AND n2.playerId = $playerId)\n      \n      // Only collect entities and relationships once all events are processed\n      WITH p, events, \n           collect(distinct r1) as outRels, collect(distinct n1) as outNodes,\n           collect(distinct r2) as inRels, collect(distinct n2) as inNodes\n      \n      // Use secondary match only for the key relationships instead of all entities\n      // This saves a lot of processing time by being more selective\n      WITH p, events, outRels, outNodes, inRels, inNodes\n      \n      // Get secondary relationships between the most important entities only\n      UNWIND outNodes as n1\n      OPTIONAL MATCH (n1)-[r3]->(n3)\n      WHERE n3 <> n1 AND NOT n3 IN events\n      \n      RETURN \n        collect(distinct p) as players,\n        events,\n        outNodes + inNodes + collect(distinct n3) as entities,\n        outRels + inRels + collect(distinct r3) as relationships\n      ","service":"mindrune-api","timestamp":"2025-03-30 10:38:02"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): outNodes, inNodes, outRels, inRels (line 60, column 9 (offset: 2185))\n\"        outNodes + inNodes + collect(distinct n3) as entities,\"\n         ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 10:38:02"}
{"level":"error","message":"Neo4j error: Variable `players` not defined (line 54, column 64 (offset: 2011))\n\"            WHERE (n1 IS NULL OR NOT n1:Player OR NOT any(p IN players WHERE p.playerId = n1.playerId))\"\n                                                                ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n          // Get players first with limit and efficient indexing\n          MATCH (p:Player {account: $account})\n          WITH collect(p) AS all_players\n          WITH all_players[0..100] AS players // Reasonable limit to avoid overwhelming query\n          \n          // Get events in parallel using CALL block\n          CALL {\n            WITH players\n            \n            // Process each player in batches for better performance\n            UNWIND players AS p\n            \n            // Split event gathering into separate UNION operations\n            CALL {\n              // Events where player is target\n              WITH p\n              MATCH (e)-[]->(p)\n              RETURN p.playerId AS playerId, collect(DISTINCT e) AS events\n              \n              UNION\n              \n              // Events where player is source\n              WITH p\n              MATCH (p)-[]->(e)\n              RETURN p.playerId AS playerId, collect(DISTINCT e) AS events\n            }\n            \n            // Return player and their events\n            RETURN playerId, events\n          }\n          \n          // Merge events by player and prepare for relationship processing\n          WITH players, collect({playerId: playerId, events: events}) AS player_events\n          \n          // Process all events in one batch\n          WITH players, \n               reduce(acc = [], pe IN player_events | acc + pe.events) AS all_events\n          \n          // Filter unique events\n          WITH players, apoc.coll.toSet(all_events) AS unique_events\n          \n          // Get relationships for all entities in one operation\n          CALL {\n            WITH unique_events\n            UNWIND unique_events AS e\n            \n            // Get all relationships in one pass\n            OPTIONAL MATCH (e)-[r1]->(n1)\n            OPTIONAL MATCH (n2)-[r2]->(e)\n            \n            // Skip player nodes we already have\n            WITH e, r1, n1, r2, n2\n            WHERE (n1 IS NULL OR NOT n1:Player OR NOT any(p IN players WHERE p.playerId = n1.playerId))\n               AND (n2 IS NULL OR NOT n2:Player OR NOT any(p IN players WHERE p.playerId = n2.playerId))\n            \n            RETURN \n              collect(DISTINCT n1) + collect(DISTINCT n2) AS related_entities,\n              collect(DISTINCT r1) + collect(DISTINCT r2) AS relationships\n          }\n          \n          // Return final data structure\n          RETURN {\n            players: players,\n            events: unique_events,\n            entities: related_entities,\n            relationships: relationships\n          } AS result","service":"mindrune-api","timestamp":"2025-03-30 12:05:20"}
{"level":"error","message":"500 - Neo4j error: Variable `players` not defined (line 54, column 64 (offset: 2011))\n\"            WHERE (n1 IS NULL OR NOT n1:Player OR NOT any(p IN players WHERE p.playerId = n1.playerId))\"\n                                                                ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:05:20"}
{"level":"error","message":"Neo4j error: Variable `players` not defined (line 54, column 64 (offset: 2011))\n\"            WHERE (n1 IS NULL OR NOT n1:Player OR NOT any(p IN players WHERE p.playerId = n1.playerId))\"\n                                                                ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n          // Get players first with limit and efficient indexing\n          MATCH (p:Player {account: $account})\n          WITH collect(p) AS all_players\n          WITH all_players[0..100] AS players // Reasonable limit to avoid overwhelming query\n          \n          // Get events in parallel using CALL block\n          CALL {\n            WITH players\n            \n            // Process each player in batches for better performance\n            UNWIND players AS p\n            \n            // Split event gathering into separate UNION operations\n            CALL {\n              // Events where player is target\n              WITH p\n              MATCH (e)-[]->(p)\n              RETURN p.playerId AS playerId, collect(DISTINCT e) AS events\n              \n              UNION\n              \n              // Events where player is source\n              WITH p\n              MATCH (p)-[]->(e)\n              RETURN p.playerId AS playerId, collect(DISTINCT e) AS events\n            }\n            \n            // Return player and their events\n            RETURN playerId, events\n          }\n          \n          // Merge events by player and prepare for relationship processing\n          WITH players, collect({playerId: playerId, events: events}) AS player_events\n          \n          // Process all events in one batch\n          WITH players, \n               reduce(acc = [], pe IN player_events | acc + pe.events) AS all_events\n          \n          // Filter unique events\n          WITH players, apoc.coll.toSet(all_events) AS unique_events\n          \n          // Get relationships for all entities in one operation\n          CALL {\n            WITH unique_events\n            UNWIND unique_events AS e\n            \n            // Get all relationships in one pass\n            OPTIONAL MATCH (e)-[r1]->(n1)\n            OPTIONAL MATCH (n2)-[r2]->(e)\n            \n            // Skip player nodes we already have\n            WITH e, r1, n1, r2, n2\n            WHERE (n1 IS NULL OR NOT n1:Player OR NOT any(p IN players WHERE p.playerId = n1.playerId))\n               AND (n2 IS NULL OR NOT n2:Player OR NOT any(p IN players WHERE p.playerId = n2.playerId))\n            \n            RETURN \n              collect(DISTINCT n1) + collect(DISTINCT n2) AS related_entities,\n              collect(DISTINCT r1) + collect(DISTINCT r2) AS relationships\n          }\n          \n          // Return final data structure\n          RETURN {\n            players: players,\n            events: unique_events,\n            entities: related_entities,\n            relationships: relationships\n          } AS result","service":"mindrune-api","timestamp":"2025-03-30 12:05:20"}
{"level":"error","message":"500 - Neo4j error: Variable `players` not defined (line 54, column 64 (offset: 2011))\n\"            WHERE (n1 IS NULL OR NOT n1:Player OR NOT any(p IN players WHERE p.playerId = n1.playerId))\"\n                                                                ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:05:20"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): players, events (line 34, column 24 (offset: 1294))\n\"              players: players,\"\n                        ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n            // Match players with limit\n            MATCH (p:Player {account: $account})\n            WITH p LIMIT 100\n            \n            // Use a direct approach to collect events\n            OPTIONAL MATCH (e1)-[]->(p)\n            OPTIONAL MATCH (p)-[]->(e2)\n            \n            // Group by player\n            WITH p, collect(DISTINCT e1) + collect(DISTINCT e2) AS player_events\n            \n            // Collect all player data\n            WITH collect({player: p, events: player_events}) AS all_player_data\n            \n            // Extract players and events\n            WITH \n              [pd IN all_player_data | pd.player] AS players,\n              reduce(acc = [], pd IN all_player_data | acc + pd.events) AS all_events\n            \n            // Remove duplicates from events\n            WITH players, collect(DISTINCT all_events) AS events_nested\n            UNWIND events_nested AS events_list\n            UNWIND events_list AS event\n            WITH players, collect(DISTINCT event) AS events\n            \n            // Get related entities\n            UNWIND events AS ev\n            OPTIONAL MATCH (ev)-[r1]->(n1)\n            OPTIONAL MATCH (n2)-[r2]->(ev)\n            \n            // Return optimized data structure\n            RETURN {\n              players: players,\n              events: events,\n              entities: collect(DISTINCT n1) + collect(DISTINCT n2),\n              relationships: collect(DISTINCT r1) + collect(DISTINCT r2)\n            } AS result","service":"mindrune-api","timestamp":"2025-03-30 12:05:20"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): players, events (line 34, column 24 (offset: 1294))\n\"              players: players,\"\n                        ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:05:20"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): players, events (line 34, column 24 (offset: 1294))\n\"              players: players,\"\n                        ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n            // Match players with limit\n            MATCH (p:Player {account: $account})\n            WITH p LIMIT 100\n            \n            // Use a direct approach to collect events\n            OPTIONAL MATCH (e1)-[]->(p)\n            OPTIONAL MATCH (p)-[]->(e2)\n            \n            // Group by player\n            WITH p, collect(DISTINCT e1) + collect(DISTINCT e2) AS player_events\n            \n            // Collect all player data\n            WITH collect({player: p, events: player_events}) AS all_player_data\n            \n            // Extract players and events\n            WITH \n              [pd IN all_player_data | pd.player] AS players,\n              reduce(acc = [], pd IN all_player_data | acc + pd.events) AS all_events\n            \n            // Remove duplicates from events\n            WITH players, collect(DISTINCT all_events) AS events_nested\n            UNWIND events_nested AS events_list\n            UNWIND events_list AS event\n            WITH players, collect(DISTINCT event) AS events\n            \n            // Get related entities\n            UNWIND events AS ev\n            OPTIONAL MATCH (ev)-[r1]->(n1)\n            OPTIONAL MATCH (n2)-[r2]->(ev)\n            \n            // Return optimized data structure\n            RETURN {\n              players: players,\n              events: events,\n              entities: collect(DISTINCT n1) + collect(DISTINCT n2),\n              relationships: collect(DISTINCT r1) + collect(DISTINCT r2)\n            } AS result","service":"mindrune-api","timestamp":"2025-03-30 12:05:20"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): players, events (line 34, column 24 (offset: 1294))\n\"              players: players,\"\n                        ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:05:20"}
{"level":"error","message":"Neo4j error: Variable `players` not defined (line 54, column 64 (offset: 2011))\n\"            WHERE (n1 IS NULL OR NOT n1:Player OR NOT any(p IN players WHERE p.playerId = n1.playerId))\"\n                                                                ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n          // Get players first with limit and efficient indexing\n          MATCH (p:Player {account: $account})\n          WITH collect(p) AS all_players\n          WITH all_players[0..100] AS players // Reasonable limit to avoid overwhelming query\n          \n          // Get events in parallel using CALL block\n          CALL {\n            WITH players\n            \n            // Process each player in batches for better performance\n            UNWIND players AS p\n            \n            // Split event gathering into separate UNION operations\n            CALL {\n              // Events where player is target\n              WITH p\n              MATCH (e)-[]->(p)\n              RETURN p.playerId AS playerId, collect(DISTINCT e) AS events\n              \n              UNION\n              \n              // Events where player is source\n              WITH p\n              MATCH (p)-[]->(e)\n              RETURN p.playerId AS playerId, collect(DISTINCT e) AS events\n            }\n            \n            // Return player and their events\n            RETURN playerId, events\n          }\n          \n          // Merge events by player and prepare for relationship processing\n          WITH players, collect({playerId: playerId, events: events}) AS player_events\n          \n          // Process all events in one batch\n          WITH players, \n               reduce(acc = [], pe IN player_events | acc + pe.events) AS all_events\n          \n          // Filter unique events\n          WITH players, apoc.coll.toSet(all_events) AS unique_events\n          \n          // Get relationships for all entities in one operation\n          CALL {\n            WITH unique_events\n            UNWIND unique_events AS e\n            \n            // Get all relationships in one pass\n            OPTIONAL MATCH (e)-[r1]->(n1)\n            OPTIONAL MATCH (n2)-[r2]->(e)\n            \n            // Skip player nodes we already have\n            WITH e, r1, n1, r2, n2\n            WHERE (n1 IS NULL OR NOT n1:Player OR NOT any(p IN players WHERE p.playerId = n1.playerId))\n               AND (n2 IS NULL OR NOT n2:Player OR NOT any(p IN players WHERE p.playerId = n2.playerId))\n            \n            RETURN \n              collect(DISTINCT n1) + collect(DISTINCT n2) AS related_entities,\n              collect(DISTINCT r1) + collect(DISTINCT r2) AS relationships\n          }\n          \n          // Return final data structure\n          RETURN {\n            players: players,\n            events: unique_events,\n            entities: related_entities,\n            relationships: relationships\n          } AS result","service":"mindrune-api","timestamp":"2025-03-30 12:05:24"}
{"level":"error","message":"500 - Neo4j error: Variable `players` not defined (line 54, column 64 (offset: 2011))\n\"            WHERE (n1 IS NULL OR NOT n1:Player OR NOT any(p IN players WHERE p.playerId = n1.playerId))\"\n                                                                ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:05:24"}
{"level":"error","message":"Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): players, events (line 34, column 24 (offset: 1294))\n\"              players: players,\"\n                        ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n            // Match players with limit\n            MATCH (p:Player {account: $account})\n            WITH p LIMIT 100\n            \n            // Use a direct approach to collect events\n            OPTIONAL MATCH (e1)-[]->(p)\n            OPTIONAL MATCH (p)-[]->(e2)\n            \n            // Group by player\n            WITH p, collect(DISTINCT e1) + collect(DISTINCT e2) AS player_events\n            \n            // Collect all player data\n            WITH collect({player: p, events: player_events}) AS all_player_data\n            \n            // Extract players and events\n            WITH \n              [pd IN all_player_data | pd.player] AS players,\n              reduce(acc = [], pd IN all_player_data | acc + pd.events) AS all_events\n            \n            // Remove duplicates from events\n            WITH players, collect(DISTINCT all_events) AS events_nested\n            UNWIND events_nested AS events_list\n            UNWIND events_list AS event\n            WITH players, collect(DISTINCT event) AS events\n            \n            // Get related entities\n            UNWIND events AS ev\n            OPTIONAL MATCH (ev)-[r1]->(n1)\n            OPTIONAL MATCH (n2)-[r2]->(ev)\n            \n            // Return optimized data structure\n            RETURN {\n              players: players,\n              events: events,\n              entities: collect(DISTINCT n1) + collect(DISTINCT n2),\n              relationships: collect(DISTINCT r1) + collect(DISTINCT r2)\n            } AS result","service":"mindrune-api","timestamp":"2025-03-30 12:05:24"}
{"level":"error","message":"500 - Neo4j error: Aggregation column contains implicit grouping expressions. For example, in 'RETURN n.a, n.a + n.b + count(*)' the aggregation expression 'n.a + n.b + count(*)' includes the implicit grouping key 'n.b'. It may be possible to rewrite the query by extracting these grouping/aggregation expressions into a preceding WITH clause. Illegal expression(s): players, events (line 34, column 24 (offset: 1294))\n\"              players: players,\"\n                        ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:05:24"}
{"level":"error","message":"Neo4j error: Unknown function 'apoc.coll.flatten' (line 58, column 15 (offset: 2119))\n\"              apoc.coll.flatten(collect(outgoing)) AS outgoing_data,\"\n               ^","params":{"account":"oauth2|discord|177946696251211776","playerId":-1617514147593677000},"query":"\n          // Match our player once\n          MATCH (p:Player {account: $account, playerId: $playerId})\n          \n          // Store in a separate named context for reuse\n          CALL {\n            WITH p\n            \n            // Split event gathering into separate UNION operations that can be parallelized\n            CALL {\n              // Events where player is target (incoming relationships)\n              MATCH (e)-[r:PERFORMED_BY|GAINED_BY|RECEIVED_BY|TARGETED]->(p)\n              RETURN collect(DISTINCT e) AS incoming_events\n              \n              UNION\n              \n              // Events where player is source (outgoing relationships)\n              MATCH (p)-[r:PERFORMED|KILLED]->(e)\n              RETURN collect(DISTINCT e) AS incoming_events\n            }\n            \n            // Return all events limited to 300\n            RETURN incoming_events AS player_events\n          }\n          \n          // Limit events right after collection\n          WITH p, player_events[0..300] AS limited_events\n          \n          // Skip further processing if no events found\n          WITH p, limited_events, size(limited_events) > 0 AS has_events\n          \n          // Gather related nodes only when we have events\n          CALL {\n            WITH limited_events, has_events\n            WITH limited_events WHERE has_events\n            \n            UNWIND limited_events AS e\n            \n            // Process outgoing relationships from events\n            CALL {\n              WITH e\n              MATCH (e)-[r1]->(n1)\n              WHERE NOT type(r1) = \"PART_OF\"\n              RETURN collect(DISTINCT {node: n1, rel: r1}) AS outgoing\n            }\n            \n            // Process incoming relationships to events\n            CALL {\n              WITH e\n              MATCH (n2)-[r2]->(e)\n              WHERE NOT n2:Player OR NOT n2.playerId = $playerId\n              RETURN collect(DISTINCT {node: n2, rel: r2}) AS incoming\n            }\n            \n            // Return combined relationships data\n            RETURN \n              collect(DISTINCT e) AS all_events,\n              apoc.coll.flatten(collect(outgoing)) AS outgoing_data,\n              apoc.coll.flatten(collect(incoming)) AS incoming_data\n          }\n          \n          // Process results for single player with proper fallback\n          RETURN CASE WHEN has_events\n            THEN {\n              players: [p],\n              events: all_events,\n              entities: outgoing_data.node + incoming_data.node,\n              relationships: outgoing_data.rel + incoming_data.rel\n            }\n            ELSE {\n              players: [p],\n              events: [],\n              entities: [],\n              relationships: []\n            }\n          END AS result","service":"mindrune-api","timestamp":"2025-03-30 12:05:25"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'apoc.coll.flatten' (line 58, column 15 (offset: 2119))\n\"              apoc.coll.flatten(collect(outgoing)) AS outgoing_data,\"\n               ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:05:25"}
{"level":"error","message":"Neo4j error: Unknown function 'apoc.coll.flatten' (line 58, column 15 (offset: 2119))\n\"              apoc.coll.flatten(collect(outgoing)) AS outgoing_data,\"\n               ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n          // Match our player once\n          MATCH (p:Player {account: $account, playerId: $playerId})\n          \n          // Store in a separate named context for reuse\n          CALL {\n            WITH p\n            \n            // Split event gathering into separate UNION operations that can be parallelized\n            CALL {\n              // Events where player is target (incoming relationships)\n              MATCH (e)-[r:PERFORMED_BY|GAINED_BY|RECEIVED_BY|TARGETED]->(p)\n              RETURN collect(DISTINCT e) AS incoming_events\n              \n              UNION\n              \n              // Events where player is source (outgoing relationships)\n              MATCH (p)-[r:PERFORMED|KILLED]->(e)\n              RETURN collect(DISTINCT e) AS incoming_events\n            }\n            \n            // Return all events limited to 300\n            RETURN incoming_events AS player_events\n          }\n          \n          // Limit events right after collection\n          WITH p, player_events[0..300] AS limited_events\n          \n          // Skip further processing if no events found\n          WITH p, limited_events, size(limited_events) > 0 AS has_events\n          \n          // Gather related nodes only when we have events\n          CALL {\n            WITH limited_events, has_events\n            WITH limited_events WHERE has_events\n            \n            UNWIND limited_events AS e\n            \n            // Process outgoing relationships from events\n            CALL {\n              WITH e\n              MATCH (e)-[r1]->(n1)\n              WHERE NOT type(r1) = \"PART_OF\"\n              RETURN collect(DISTINCT {node: n1, rel: r1}) AS outgoing\n            }\n            \n            // Process incoming relationships to events\n            CALL {\n              WITH e\n              MATCH (n2)-[r2]->(e)\n              WHERE NOT n2:Player OR NOT n2.playerId = $playerId\n              RETURN collect(DISTINCT {node: n2, rel: r2}) AS incoming\n            }\n            \n            // Return combined relationships data\n            RETURN \n              collect(DISTINCT e) AS all_events,\n              apoc.coll.flatten(collect(outgoing)) AS outgoing_data,\n              apoc.coll.flatten(collect(incoming)) AS incoming_data\n          }\n          \n          // Process results for single player with proper fallback\n          RETURN CASE WHEN has_events\n            THEN {\n              players: [p],\n              events: all_events,\n              entities: outgoing_data.node + incoming_data.node,\n              relationships: outgoing_data.rel + incoming_data.rel\n            }\n            ELSE {\n              players: [p],\n              events: [],\n              entities: [],\n              relationships: []\n            }\n          END AS result","service":"mindrune-api","timestamp":"2025-03-30 12:05:26"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'apoc.coll.flatten' (line 58, column 15 (offset: 2119))\n\"              apoc.coll.flatten(collect(outgoing)) AS outgoing_data,\"\n               ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:05:26"}
{"level":"error","message":"Neo4j error: Unknown function 'apoc.coll.flatten' (line 58, column 15 (offset: 2119))\n\"              apoc.coll.flatten(collect(outgoing)) AS outgoing_data,\"\n               ^","params":{"account":"oauth2|discord|177946696251211776","playerId":-1617514147593677000},"query":"\n          // Match our player once\n          MATCH (p:Player {account: $account, playerId: $playerId})\n          \n          // Store in a separate named context for reuse\n          CALL {\n            WITH p\n            \n            // Split event gathering into separate UNION operations that can be parallelized\n            CALL {\n              // Events where player is target (incoming relationships)\n              MATCH (e)-[r:PERFORMED_BY|GAINED_BY|RECEIVED_BY|TARGETED]->(p)\n              RETURN collect(DISTINCT e) AS incoming_events\n              \n              UNION\n              \n              // Events where player is source (outgoing relationships)\n              MATCH (p)-[r:PERFORMED|KILLED]->(e)\n              RETURN collect(DISTINCT e) AS incoming_events\n            }\n            \n            // Return all events limited to 300\n            RETURN incoming_events AS player_events\n          }\n          \n          // Limit events right after collection\n          WITH p, player_events[0..300] AS limited_events\n          \n          // Skip further processing if no events found\n          WITH p, limited_events, size(limited_events) > 0 AS has_events\n          \n          // Gather related nodes only when we have events\n          CALL {\n            WITH limited_events, has_events\n            WITH limited_events WHERE has_events\n            \n            UNWIND limited_events AS e\n            \n            // Process outgoing relationships from events\n            CALL {\n              WITH e\n              MATCH (e)-[r1]->(n1)\n              WHERE NOT type(r1) = \"PART_OF\"\n              RETURN collect(DISTINCT {node: n1, rel: r1}) AS outgoing\n            }\n            \n            // Process incoming relationships to events\n            CALL {\n              WITH e\n              MATCH (n2)-[r2]->(e)\n              WHERE NOT n2:Player OR NOT n2.playerId = $playerId\n              RETURN collect(DISTINCT {node: n2, rel: r2}) AS incoming\n            }\n            \n            // Return combined relationships data\n            RETURN \n              collect(DISTINCT e) AS all_events,\n              apoc.coll.flatten(collect(outgoing)) AS outgoing_data,\n              apoc.coll.flatten(collect(incoming)) AS incoming_data\n          }\n          \n          // Process results for single player with proper fallback\n          RETURN CASE WHEN has_events\n            THEN {\n              players: [p],\n              events: all_events,\n              entities: outgoing_data.node + incoming_data.node,\n              relationships: outgoing_data.rel + incoming_data.rel\n            }\n            ELSE {\n              players: [p],\n              events: [],\n              entities: [],\n              relationships: []\n            }\n          END AS result","service":"mindrune-api","timestamp":"2025-03-30 12:05:31"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'apoc.coll.flatten' (line 58, column 15 (offset: 2119))\n\"              apoc.coll.flatten(collect(outgoing)) AS outgoing_data,\"\n               ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:05:31"}
{"level":"error","message":"Neo4j error: In a WITH/RETURN with DISTINCT or an aggregation, it is not possible to access variables declared before the WITH/RETURN: event (line 41, column 67 (offset: 1526))\n\"            WITH players, collect(DISTINCT event) AS events WHERE event IS NOT NULL\"\n                                                                   ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n          // First match all players for this account\n          MATCH (p:Player {account: $account})\n          \n          // Collect all players and process them in parallel\n          WITH collect(p) AS all_players\n          \n          CALL {\n            WITH all_players\n            UNWIND all_players AS p\n            \n            // Get player events efficiently with CALL blocks\n            CALL {\n              WITH p\n              MATCH (e)-[]->(p)\n              RETURN collect(DISTINCT e) AS in_events\n            }\n            \n            CALL {\n              WITH p\n              MATCH (p)-[]->(e)\n              RETURN collect(DISTINCT e) AS out_events\n            }\n            \n            WITH p, in_events + out_events AS player_events\n            RETURN collect({player: p, events: player_events}) AS player_data\n          }\n          \n          // Process all events and relationships\n          WITH player_data\n          CALL {\n            WITH player_data\n            UNWIND player_data AS pd\n            WITH pd.player AS player, pd.events AS events\n            WITH collect(DISTINCT player) AS players, \n                 CASE WHEN size(apoc.coll.flatten(collect(events))) > 0 THEN apoc.coll.flatten(collect(events)) ELSE [] END AS all_events\n            \n            // Use efficient UNWIND only when necessary\n            WITH players, all_events\n            UNWIND CASE WHEN size(all_events) > 0 THEN all_events ELSE [null] END AS event\n            WITH players, collect(DISTINCT event) AS events WHERE event IS NOT NULL\n            \n            // Process relationships\n            CALL {\n              WITH events\n              UNWIND events AS ev\n              MATCH (ev)-[r3]->(n1)\n              RETURN collect(DISTINCT n1) AS out_nodes, collect(DISTINCT r3) AS out_rels\n            }\n            \n            CALL {\n              WITH events\n              UNWIND events AS ev\n              MATCH (n2)-[r4]->(ev)\n              RETURN collect(DISTINCT n2) AS in_nodes, collect(DISTINCT r4) AS in_rels\n            }\n            \n            RETURN players, events, out_nodes + in_nodes AS entities, out_rels + in_rels AS relationships\n          }\n          \n          RETURN players, events, entities, relationships\n          ","service":"mindrune-api","timestamp":"2025-03-30 12:08:12"}
{"level":"error","message":"500 - Neo4j error: In a WITH/RETURN with DISTINCT or an aggregation, it is not possible to access variables declared before the WITH/RETURN: event (line 41, column 67 (offset: 1526))\n\"            WITH players, collect(DISTINCT event) AS events WHERE event IS NOT NULL\"\n                                                                   ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:08:12"}
{"level":"error","message":"Neo4j error: In a WITH/RETURN with DISTINCT or an aggregation, it is not possible to access variables declared before the WITH/RETURN: event (line 41, column 67 (offset: 1526))\n\"            WITH players, collect(DISTINCT event) AS events WHERE event IS NOT NULL\"\n                                                                   ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n          // First match all players for this account\n          MATCH (p:Player {account: $account})\n          \n          // Collect all players and process them in parallel\n          WITH collect(p) AS all_players\n          \n          CALL {\n            WITH all_players\n            UNWIND all_players AS p\n            \n            // Get player events efficiently with CALL blocks\n            CALL {\n              WITH p\n              MATCH (e)-[]->(p)\n              RETURN collect(DISTINCT e) AS in_events\n            }\n            \n            CALL {\n              WITH p\n              MATCH (p)-[]->(e)\n              RETURN collect(DISTINCT e) AS out_events\n            }\n            \n            WITH p, in_events + out_events AS player_events\n            RETURN collect({player: p, events: player_events}) AS player_data\n          }\n          \n          // Process all events and relationships\n          WITH player_data\n          CALL {\n            WITH player_data\n            UNWIND player_data AS pd\n            WITH pd.player AS player, pd.events AS events\n            WITH collect(DISTINCT player) AS players, \n                 CASE WHEN size(apoc.coll.flatten(collect(events))) > 0 THEN apoc.coll.flatten(collect(events)) ELSE [] END AS all_events\n            \n            // Use efficient UNWIND only when necessary\n            WITH players, all_events\n            UNWIND CASE WHEN size(all_events) > 0 THEN all_events ELSE [null] END AS event\n            WITH players, collect(DISTINCT event) AS events WHERE event IS NOT NULL\n            \n            // Process relationships\n            CALL {\n              WITH events\n              UNWIND events AS ev\n              MATCH (ev)-[r3]->(n1)\n              RETURN collect(DISTINCT n1) AS out_nodes, collect(DISTINCT r3) AS out_rels\n            }\n            \n            CALL {\n              WITH events\n              UNWIND events AS ev\n              MATCH (n2)-[r4]->(ev)\n              RETURN collect(DISTINCT n2) AS in_nodes, collect(DISTINCT r4) AS in_rels\n            }\n            \n            RETURN players, events, out_nodes + in_nodes AS entities, out_rels + in_rels AS relationships\n          }\n          \n          RETURN players, events, entities, relationships\n          ","service":"mindrune-api","timestamp":"2025-03-30 12:08:12"}
{"level":"error","message":"500 - Neo4j error: In a WITH/RETURN with DISTINCT or an aggregation, it is not possible to access variables declared before the WITH/RETURN: event (line 41, column 67 (offset: 1526))\n\"            WITH players, collect(DISTINCT event) AS events WHERE event IS NOT NULL\"\n                                                                   ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:08:12"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:08:15"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:08:15"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":-1617514147593677000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:08:15"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:08:15"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:08:16"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:08:16"}
{"level":"error","message":"Neo4j error: In a WITH/RETURN with DISTINCT or an aggregation, it is not possible to access variables declared before the WITH/RETURN: event (line 41, column 67 (offset: 1526))\n\"            WITH players, collect(DISTINCT event) AS events WHERE event IS NOT NULL\"\n                                                                   ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n          // First match all players for this account\n          MATCH (p:Player {account: $account})\n          \n          // Collect all players and process them in parallel\n          WITH collect(p) AS all_players\n          \n          CALL {\n            WITH all_players\n            UNWIND all_players AS p\n            \n            // Get player events efficiently with CALL blocks\n            CALL {\n              WITH p\n              MATCH (e)-[]->(p)\n              RETURN collect(DISTINCT e) AS in_events\n            }\n            \n            CALL {\n              WITH p\n              MATCH (p)-[]->(e)\n              RETURN collect(DISTINCT e) AS out_events\n            }\n            \n            WITH p, in_events + out_events AS player_events\n            RETURN collect({player: p, events: player_events}) AS player_data\n          }\n          \n          // Process all events and relationships\n          WITH player_data\n          CALL {\n            WITH player_data\n            UNWIND player_data AS pd\n            WITH pd.player AS player, pd.events AS events\n            WITH collect(DISTINCT player) AS players, \n                 CASE WHEN size(apoc.coll.flatten(collect(events))) > 0 THEN apoc.coll.flatten(collect(events)) ELSE [] END AS all_events\n            \n            // Use efficient UNWIND only when necessary\n            WITH players, all_events\n            UNWIND CASE WHEN size(all_events) > 0 THEN all_events ELSE [null] END AS event\n            WITH players, collect(DISTINCT event) AS events WHERE event IS NOT NULL\n            \n            // Process relationships\n            CALL {\n              WITH events\n              UNWIND events AS ev\n              MATCH (ev)-[r3]->(n1)\n              RETURN collect(DISTINCT n1) AS out_nodes, collect(DISTINCT r3) AS out_rels\n            }\n            \n            CALL {\n              WITH events\n              UNWIND events AS ev\n              MATCH (n2)-[r4]->(ev)\n              RETURN collect(DISTINCT n2) AS in_nodes, collect(DISTINCT r4) AS in_rels\n            }\n            \n            RETURN players, events, out_nodes + in_nodes AS entities, out_rels + in_rels AS relationships\n          }\n          \n          RETURN players, events, entities, relationships\n          ","service":"mindrune-api","timestamp":"2025-03-30 12:08:17"}
{"level":"error","message":"500 - Neo4j error: In a WITH/RETURN with DISTINCT or an aggregation, it is not possible to access variables declared before the WITH/RETURN: event (line 41, column 67 (offset: 1526))\n\"            WITH players, collect(DISTINCT event) AS events WHERE event IS NOT NULL\"\n                                                                   ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:08:17"}
{"level":"error","message":"Neo4j error: Invalid input 'WHERE': expected 'FOREACH', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'WITH' or '}' (line 41, column 13 (offset: 1472))\n\"            WHERE event IS NOT NULL\"\n             ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n          // First match all players for this account\n          MATCH (p:Player {account: $account})\n          \n          // Collect all players and process them in parallel\n          WITH collect(p) AS all_players\n          \n          CALL {\n            WITH all_players\n            UNWIND all_players AS p\n            \n            // Get player events efficiently with CALL blocks\n            CALL {\n              WITH p\n              MATCH (e)-[]->(p)\n              RETURN collect(DISTINCT e) AS in_events\n            }\n            \n            CALL {\n              WITH p\n              MATCH (p)-[]->(e)\n              RETURN collect(DISTINCT e) AS out_events\n            }\n            \n            WITH p, in_events + out_events AS player_events\n            RETURN collect({player: p, events: player_events}) AS player_data\n          }\n          \n          // Process all events and relationships\n          WITH player_data\n          CALL {\n            WITH player_data\n            UNWIND player_data AS pd\n            WITH pd.player AS player, pd.events AS events\n            WITH collect(DISTINCT player) AS players, \n                 CASE WHEN size(apoc.coll.flatten(collect(events))) > 0 THEN apoc.coll.flatten(collect(events)) ELSE [] END AS all_events\n            \n            // Use efficient UNWIND only when necessary\n            WITH players, all_events\n            UNWIND CASE WHEN size(all_events) > 0 THEN all_events ELSE [null] END AS event\n            WHERE event IS NOT NULL\n            WITH players, collect(DISTINCT event) AS events\n            \n            // Process relationships\n            CALL {\n              WITH events\n              UNWIND events AS ev\n              MATCH (ev)-[r3]->(n1)\n              RETURN collect(DISTINCT n1) AS out_nodes, collect(DISTINCT r3) AS out_rels\n            }\n            \n            CALL {\n              WITH events\n              UNWIND events AS ev\n              MATCH (n2)-[r4]->(ev)\n              RETURN collect(DISTINCT n2) AS in_nodes, collect(DISTINCT r4) AS in_rels\n            }\n            \n            RETURN players, events, out_nodes + in_nodes AS entities, out_rels + in_rels AS relationships\n          }\n          \n          RETURN players, events, entities, relationships\n          ","service":"mindrune-api","timestamp":"2025-03-30 12:08:52"}
{"level":"error","message":"500 - Neo4j error: Invalid input 'WHERE': expected 'FOREACH', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'WITH' or '}' (line 41, column 13 (offset: 1472))\n\"            WHERE event IS NOT NULL\"\n             ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:08:52"}
{"level":"error","message":"Neo4j error: Invalid input 'WHERE': expected 'FOREACH', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'WITH' or '}' (line 41, column 13 (offset: 1472))\n\"            WHERE event IS NOT NULL\"\n             ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n          // First match all players for this account\n          MATCH (p:Player {account: $account})\n          \n          // Collect all players and process them in parallel\n          WITH collect(p) AS all_players\n          \n          CALL {\n            WITH all_players\n            UNWIND all_players AS p\n            \n            // Get player events efficiently with CALL blocks\n            CALL {\n              WITH p\n              MATCH (e)-[]->(p)\n              RETURN collect(DISTINCT e) AS in_events\n            }\n            \n            CALL {\n              WITH p\n              MATCH (p)-[]->(e)\n              RETURN collect(DISTINCT e) AS out_events\n            }\n            \n            WITH p, in_events + out_events AS player_events\n            RETURN collect({player: p, events: player_events}) AS player_data\n          }\n          \n          // Process all events and relationships\n          WITH player_data\n          CALL {\n            WITH player_data\n            UNWIND player_data AS pd\n            WITH pd.player AS player, pd.events AS events\n            WITH collect(DISTINCT player) AS players, \n                 CASE WHEN size(apoc.coll.flatten(collect(events))) > 0 THEN apoc.coll.flatten(collect(events)) ELSE [] END AS all_events\n            \n            // Use efficient UNWIND only when necessary\n            WITH players, all_events\n            UNWIND CASE WHEN size(all_events) > 0 THEN all_events ELSE [null] END AS event\n            WHERE event IS NOT NULL\n            WITH players, collect(DISTINCT event) AS events\n            \n            // Process relationships\n            CALL {\n              WITH events\n              UNWIND events AS ev\n              MATCH (ev)-[r3]->(n1)\n              RETURN collect(DISTINCT n1) AS out_nodes, collect(DISTINCT r3) AS out_rels\n            }\n            \n            CALL {\n              WITH events\n              UNWIND events AS ev\n              MATCH (n2)-[r4]->(ev)\n              RETURN collect(DISTINCT n2) AS in_nodes, collect(DISTINCT r4) AS in_rels\n            }\n            \n            RETURN players, events, out_nodes + in_nodes AS entities, out_rels + in_rels AS relationships\n          }\n          \n          RETURN players, events, entities, relationships\n          ","service":"mindrune-api","timestamp":"2025-03-30 12:08:52"}
{"level":"error","message":"500 - Neo4j error: Invalid input 'WHERE': expected 'FOREACH', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'WITH' or '}' (line 41, column 13 (offset: 1472))\n\"            WHERE event IS NOT NULL\"\n             ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:08:52"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:08:55"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:08:55"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":-1617514147593677000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:08:56"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:08:56"}
{"level":"error","message":"Neo4j error: Invalid input 'WHERE': expected 'FOREACH', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'WITH' or '}' (line 41, column 13 (offset: 1472))\n\"            WHERE event IS NOT NULL\"\n             ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n          // First match all players for this account\n          MATCH (p:Player {account: $account})\n          \n          // Collect all players and process them in parallel\n          WITH collect(p) AS all_players\n          \n          CALL {\n            WITH all_players\n            UNWIND all_players AS p\n            \n            // Get player events efficiently with CALL blocks\n            CALL {\n              WITH p\n              MATCH (e)-[]->(p)\n              RETURN collect(DISTINCT e) AS in_events\n            }\n            \n            CALL {\n              WITH p\n              MATCH (p)-[]->(e)\n              RETURN collect(DISTINCT e) AS out_events\n            }\n            \n            WITH p, in_events + out_events AS player_events\n            RETURN collect({player: p, events: player_events}) AS player_data\n          }\n          \n          // Process all events and relationships\n          WITH player_data\n          CALL {\n            WITH player_data\n            UNWIND player_data AS pd\n            WITH pd.player AS player, pd.events AS events\n            WITH collect(DISTINCT player) AS players, \n                 CASE WHEN size(apoc.coll.flatten(collect(events))) > 0 THEN apoc.coll.flatten(collect(events)) ELSE [] END AS all_events\n            \n            // Use efficient UNWIND only when necessary\n            WITH players, all_events\n            UNWIND CASE WHEN size(all_events) > 0 THEN all_events ELSE [null] END AS event\n            WHERE event IS NOT NULL\n            WITH players, collect(DISTINCT event) AS events\n            \n            // Process relationships\n            CALL {\n              WITH events\n              UNWIND events AS ev\n              MATCH (ev)-[r3]->(n1)\n              RETURN collect(DISTINCT n1) AS out_nodes, collect(DISTINCT r3) AS out_rels\n            }\n            \n            CALL {\n              WITH events\n              UNWIND events AS ev\n              MATCH (n2)-[r4]->(ev)\n              RETURN collect(DISTINCT n2) AS in_nodes, collect(DISTINCT r4) AS in_rels\n            }\n            \n            RETURN players, events, out_nodes + in_nodes AS entities, out_rels + in_rels AS relationships\n          }\n          \n          RETURN players, events, entities, relationships\n          ","service":"mindrune-api","timestamp":"2025-03-30 12:08:56"}
{"level":"error","message":"500 - Neo4j error: Invalid input 'WHERE': expected 'FOREACH', 'ORDER BY', 'CALL', 'CREATE', 'LOAD CSV', 'DELETE', 'DETACH', 'FINISH', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REMOVE', 'RETURN', 'SET', 'SKIP', 'UNION', 'UNWIND', 'USE', 'WITH' or '}' (line 41, column 13 (offset: 1472))\n\"            WHERE event IS NOT NULL\"\n             ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:08:56"}
{"level":"error","message":"Neo4j error: Unknown function 'apoc.coll.flatten' (line 36, column 33 (offset: 1157))\n\"                 CASE WHEN size(apoc.coll.flatten(collect(events))) > 0 THEN apoc.coll.flatten(collect(events)) ELSE [] END AS all_events\"\n                                 ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n          // First match all players for this account\n          MATCH (p:Player {account: $account})\n          \n          // Collect all players and process them in parallel\n          WITH collect(p) AS all_players\n          \n          CALL {\n            WITH all_players\n            UNWIND all_players AS p\n            \n            // Get player events efficiently with CALL blocks\n            CALL {\n              WITH p\n              MATCH (e)-[]->(p)\n              RETURN collect(DISTINCT e) AS in_events\n            }\n            \n            CALL {\n              WITH p\n              MATCH (p)-[]->(e)\n              RETURN collect(DISTINCT e) AS out_events\n            }\n            \n            WITH p, in_events + out_events AS player_events\n            RETURN collect({player: p, events: player_events}) AS player_data\n          }\n          \n          // Process all events and relationships\n          WITH player_data\n          CALL {\n            WITH player_data\n            UNWIND player_data AS pd\n            WITH pd.player AS player, pd.events AS events\n            WITH collect(DISTINCT player) AS players, \n                 CASE WHEN size(apoc.coll.flatten(collect(events))) > 0 THEN apoc.coll.flatten(collect(events)) ELSE [] END AS all_events\n            \n            // Use efficient UNWIND only when necessary\n            WITH players, all_events\n            UNWIND CASE WHEN size(all_events) > 0 THEN all_events ELSE [null] END AS event\n            WITH players, event\n            WHERE event IS NOT NULL\n            WITH players, collect(DISTINCT event) AS events\n            \n            // Process relationships\n            CALL {\n              WITH events\n              UNWIND events AS ev\n              MATCH (ev)-[r3]->(n1)\n              RETURN collect(DISTINCT n1) AS out_nodes, collect(DISTINCT r3) AS out_rels\n            }\n            \n            CALL {\n              WITH events\n              UNWIND events AS ev\n              MATCH (n2)-[r4]->(ev)\n              RETURN collect(DISTINCT n2) AS in_nodes, collect(DISTINCT r4) AS in_rels\n            }\n            \n            RETURN players, events, out_nodes + in_nodes AS entities, out_rels + in_rels AS relationships\n          }\n          \n          RETURN players, events, entities, relationships\n          ","service":"mindrune-api","timestamp":"2025-03-30 12:09:32"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'apoc.coll.flatten' (line 36, column 33 (offset: 1157))\n\"                 CASE WHEN size(apoc.coll.flatten(collect(events))) > 0 THEN apoc.coll.flatten(collect(events)) ELSE [] END AS all_events\"\n                                 ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:09:32"}
{"level":"error","message":"Neo4j error: Unknown function 'apoc.coll.flatten' (line 36, column 33 (offset: 1157))\n\"                 CASE WHEN size(apoc.coll.flatten(collect(events))) > 0 THEN apoc.coll.flatten(collect(events)) ELSE [] END AS all_events\"\n                                 ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n          // First match all players for this account\n          MATCH (p:Player {account: $account})\n          \n          // Collect all players and process them in parallel\n          WITH collect(p) AS all_players\n          \n          CALL {\n            WITH all_players\n            UNWIND all_players AS p\n            \n            // Get player events efficiently with CALL blocks\n            CALL {\n              WITH p\n              MATCH (e)-[]->(p)\n              RETURN collect(DISTINCT e) AS in_events\n            }\n            \n            CALL {\n              WITH p\n              MATCH (p)-[]->(e)\n              RETURN collect(DISTINCT e) AS out_events\n            }\n            \n            WITH p, in_events + out_events AS player_events\n            RETURN collect({player: p, events: player_events}) AS player_data\n          }\n          \n          // Process all events and relationships\n          WITH player_data\n          CALL {\n            WITH player_data\n            UNWIND player_data AS pd\n            WITH pd.player AS player, pd.events AS events\n            WITH collect(DISTINCT player) AS players, \n                 CASE WHEN size(apoc.coll.flatten(collect(events))) > 0 THEN apoc.coll.flatten(collect(events)) ELSE [] END AS all_events\n            \n            // Use efficient UNWIND only when necessary\n            WITH players, all_events\n            UNWIND CASE WHEN size(all_events) > 0 THEN all_events ELSE [null] END AS event\n            WITH players, event\n            WHERE event IS NOT NULL\n            WITH players, collect(DISTINCT event) AS events\n            \n            // Process relationships\n            CALL {\n              WITH events\n              UNWIND events AS ev\n              MATCH (ev)-[r3]->(n1)\n              RETURN collect(DISTINCT n1) AS out_nodes, collect(DISTINCT r3) AS out_rels\n            }\n            \n            CALL {\n              WITH events\n              UNWIND events AS ev\n              MATCH (n2)-[r4]->(ev)\n              RETURN collect(DISTINCT n2) AS in_nodes, collect(DISTINCT r4) AS in_rels\n            }\n            \n            RETURN players, events, out_nodes + in_nodes AS entities, out_rels + in_rels AS relationships\n          }\n          \n          RETURN players, events, entities, relationships\n          ","service":"mindrune-api","timestamp":"2025-03-30 12:09:32"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'apoc.coll.flatten' (line 36, column 33 (offset: 1157))\n\"                 CASE WHEN size(apoc.coll.flatten(collect(events))) > 0 THEN apoc.coll.flatten(collect(events)) ELSE [] END AS all_events\"\n                                 ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:09:32"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:09:33"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:09:33"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":-1617514147593677000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:09:34"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:09:34"}
{"level":"error","message":"Neo4j error: Unknown function 'apoc.coll.flatten' (line 36, column 33 (offset: 1157))\n\"                 CASE WHEN size(apoc.coll.flatten(collect(events))) > 0 THEN apoc.coll.flatten(collect(events)) ELSE [] END AS all_events\"\n                                 ^","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n          // First match all players for this account\n          MATCH (p:Player {account: $account})\n          \n          // Collect all players and process them in parallel\n          WITH collect(p) AS all_players\n          \n          CALL {\n            WITH all_players\n            UNWIND all_players AS p\n            \n            // Get player events efficiently with CALL blocks\n            CALL {\n              WITH p\n              MATCH (e)-[]->(p)\n              RETURN collect(DISTINCT e) AS in_events\n            }\n            \n            CALL {\n              WITH p\n              MATCH (p)-[]->(e)\n              RETURN collect(DISTINCT e) AS out_events\n            }\n            \n            WITH p, in_events + out_events AS player_events\n            RETURN collect({player: p, events: player_events}) AS player_data\n          }\n          \n          // Process all events and relationships\n          WITH player_data\n          CALL {\n            WITH player_data\n            UNWIND player_data AS pd\n            WITH pd.player AS player, pd.events AS events\n            WITH collect(DISTINCT player) AS players, \n                 CASE WHEN size(apoc.coll.flatten(collect(events))) > 0 THEN apoc.coll.flatten(collect(events)) ELSE [] END AS all_events\n            \n            // Use efficient UNWIND only when necessary\n            WITH players, all_events\n            UNWIND CASE WHEN size(all_events) > 0 THEN all_events ELSE [null] END AS event\n            WITH players, event\n            WHERE event IS NOT NULL\n            WITH players, collect(DISTINCT event) AS events\n            \n            // Process relationships\n            CALL {\n              WITH events\n              UNWIND events AS ev\n              MATCH (ev)-[r3]->(n1)\n              RETURN collect(DISTINCT n1) AS out_nodes, collect(DISTINCT r3) AS out_rels\n            }\n            \n            CALL {\n              WITH events\n              UNWIND events AS ev\n              MATCH (n2)-[r4]->(ev)\n              RETURN collect(DISTINCT n2) AS in_nodes, collect(DISTINCT r4) AS in_rels\n            }\n            \n            RETURN players, events, out_nodes + in_nodes AS entities, out_rels + in_rels AS relationships\n          }\n          \n          RETURN players, events, entities, relationships\n          ","service":"mindrune-api","timestamp":"2025-03-30 12:09:35"}
{"level":"error","message":"500 - Neo4j error: Unknown function 'apoc.coll.flatten' (line 36, column 33 (offset: 1157))\n\"                 CASE WHEN size(apoc.coll.flatten(collect(events))) > 0 THEN apoc.coll.flatten(collect(events)) ELSE [] END AS all_events\"\n                                 ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:09:35"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:26:03"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:26:03"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":-1617514147593677000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:26:04"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:26:04"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:26:25"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:26:25"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":-1617514147593677000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:26:30"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:26:30"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:26:33"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:26:33"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":-1617514147593677000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:26:34"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:26:34"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:26:35"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:26:35"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":-1617514147593677000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:26:36"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:26:36"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:26:36"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:26:36"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":-1617514147593677000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:26:36"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:26:36"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:26:38"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:26:38"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":-1617514147593677000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:26:39"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:26:39"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:26:40"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:26:40"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:30:21"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:30:21"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:30:21"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:30:21"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:30:34"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:30:34"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":-1617514147593677000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:30:35"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:30:35"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:30:36"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:30:36"}
{"level":"error","message":"Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n        // First collect the player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect incoming relationships in one operation\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            WHERE type(r) IN [\"PERFORMED_BY\", \"GAINED_BY\", \"RECEIVED_BY\", \"TARGETED\"]\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect outgoing relationships in one operation\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            WHERE type(r) IN [\"PERFORMED\", \"KILLED\"]\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          // Combine all events\n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN p, player_events[0..300] AS limited_events\n        }\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events, players\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE NOT n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 12:30:46"}
{"level":"error","message":"500 - Neo4j error: Variable `p` already declared in outer scope (line 27, column 18 (offset: 887))\n\"          RETURN p, player_events[0..300] AS limited_events\"\n                  ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 12:30:46"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find XP events directly\n    WITH p\n    OPTIONAL MATCH (xp)-[r1]->(p)\n    WHERE xp.eventType = 'XP_GAIN' OR any(label IN labels(xp) WHERE label CONTAINS 'XpGain')\n    \n    // Also try outgoing relationships\n    OPTIONAL MATCH (p)-[r2]->(xp2)\n    WHERE xp2.eventType = 'XP_GAIN' OR any(label IN labels(xp2) WHERE label CONTAINS 'XpGain')\n    \n    RETURN count(DISTINCT xp) AS incomingXpCount, count(DISTINCT xp2) AS outgoingXpCount\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:44"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:44"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find XP events directly\n    WITH p\n    OPTIONAL MATCH (xp)-[r1]->(p)\n    WHERE xp.eventType = 'XP_GAIN' OR any(label IN labels(xp) WHERE label CONTAINS 'XpGain')\n    \n    // Also try outgoing relationships\n    OPTIONAL MATCH (p)-[r2]->(xp2)\n    WHERE xp2.eventType = 'XP_GAIN' OR any(label IN labels(xp2) WHERE label CONTAINS 'XpGain')\n    \n    RETURN count(DISTINCT xp) AS incomingXpCount, count(DISTINCT xp2) AS outgoingXpCount\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:44"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:44"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find hit splat events directly\n    WITH p\n    OPTIONAL MATCH (hit)-[r1]->(p)\n    WHERE hit.eventType = 'HIT_SPLAT' OR any(label IN labels(hit) WHERE label CONTAINS 'HitSplat')\n    \n    // Also try outgoing relationships\n    OPTIONAL MATCH (p)-[r2]->(hit2)\n    WHERE hit2.eventType = 'HIT_SPLAT' OR any(label IN labels(hit2) WHERE label CONTAINS 'HitSplat')\n    \n    RETURN count(DISTINCT hit) AS incomingHitCount, count(DISTINCT hit2) AS outgoingHitCount\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:44"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:44"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find hit splat events directly\n    WITH p\n    OPTIONAL MATCH (hit)-[r1]->(p)\n    WHERE hit.eventType = 'HIT_SPLAT' OR any(label IN labels(hit) WHERE label CONTAINS 'HitSplat')\n    \n    // Also try outgoing relationships\n    OPTIONAL MATCH (p)-[r2]->(hit2)\n    WHERE hit2.eventType = 'HIT_SPLAT' OR any(label IN labels(hit2) WHERE label CONTAINS 'HitSplat')\n    \n    RETURN count(DISTINCT hit) AS incomingHitCount, count(DISTINCT hit2) AS outgoingHitCount\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:44"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:44"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find kill events directly\n    WITH p\n    OPTIONAL MATCH (kill)-[r1]->(p)\n    WHERE kill.eventType = 'MONSTER_KILL' OR any(label IN labels(kill) WHERE label CONTAINS 'MonsterKill')\n    \n    // Also try outgoing relationships\n    OPTIONAL MATCH (p)-[r2]->(kill2)\n    WHERE kill2.eventType = 'MONSTER_KILL' OR any(label IN labels(kill2) WHERE label CONTAINS 'MonsterKill')\n    \n    RETURN count(DISTINCT kill) AS incomingKillCount, count(DISTINCT kill2) AS outgoingKillCount\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:44"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:44"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find kill events directly\n    WITH p\n    OPTIONAL MATCH (kill)-[r1]->(p)\n    WHERE kill.eventType = 'MONSTER_KILL' OR any(label IN labels(kill) WHERE label CONTAINS 'MonsterKill')\n    \n    // Also try outgoing relationships\n    OPTIONAL MATCH (p)-[r2]->(kill2)\n    WHERE kill2.eventType = 'MONSTER_KILL' OR any(label IN labels(kill2) WHERE label CONTAINS 'MonsterKill')\n    \n    RETURN count(DISTINCT kill) AS incomingKillCount, count(DISTINCT kill2) AS outgoingKillCount\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:44"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:44"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Try to find any paths to XP, Hit, or Kill events\n    WITH p\n    \n    // Find XP events through any path up to 2 steps\n    OPTIONAL MATCH path1 = (p)-[*1..2]-(xp)\n    WHERE xp.eventType = 'XP_GAIN' OR any(label IN labels(xp) WHERE label CONTAINS 'XpGain')\n    \n    // Find HitSplat events through any path up to 2 steps\n    OPTIONAL MATCH path2 = (p)-[*1..2]-(hit)\n    WHERE hit.eventType = 'HIT_SPLAT' OR any(label IN labels(hit) WHERE label CONTAINS 'HitSplat')\n    \n    // Find Kill events through any path up to 2 steps\n    OPTIONAL MATCH path3 = (p)-[*1..2]-(kill)\n    WHERE kill.eventType = 'MONSTER_KILL' OR any(label IN labels(kill) WHERE label CONTAINS 'MonsterKill')\n    \n    RETURN count(DISTINCT path1) AS xpPaths, \n           count(DISTINCT path2) AS hitPaths,\n           count(DISTINCT path3) AS killPaths\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:45"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:45"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Try to find any paths to XP, Hit, or Kill events\n    WITH p\n    \n    // Find XP events through any path up to 2 steps\n    OPTIONAL MATCH path1 = (p)-[*1..2]-(xp)\n    WHERE xp.eventType = 'XP_GAIN' OR any(label IN labels(xp) WHERE label CONTAINS 'XpGain')\n    \n    // Find HitSplat events through any path up to 2 steps\n    OPTIONAL MATCH path2 = (p)-[*1..2]-(hit)\n    WHERE hit.eventType = 'HIT_SPLAT' OR any(label IN labels(hit) WHERE label CONTAINS 'HitSplat')\n    \n    // Find Kill events through any path up to 2 steps\n    OPTIONAL MATCH path3 = (p)-[*1..2]-(kill)\n    WHERE kill.eventType = 'MONSTER_KILL' OR any(label IN labels(kill) WHERE label CONTAINS 'MonsterKill')\n    \n    RETURN count(DISTINCT path1) AS xpPaths, \n           count(DISTINCT path2) AS hitPaths,\n           count(DISTINCT path3) AS killPaths\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:45"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:45"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find ALL events connected in any way up to 2 steps\n    MATCH (p)-[*1..2]-(e)\n    WHERE e.eventType IS NOT NULL\n    \n    RETURN e.eventType AS type, count(e) AS count\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:45"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:45"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find ALL events connected in any way up to 2 steps\n    MATCH (p)-[*1..2]-(e)\n    WHERE e.eventType IS NOT NULL\n    \n    RETURN e.eventType AS type, count(e) AS count\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:45"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:45"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find XP events directly\n    WITH p\n    OPTIONAL MATCH (xp)-[r1]->(p)\n    WHERE xp.eventType = 'XP_GAIN' OR any(label IN labels(xp) WHERE label CONTAINS 'XpGain')\n    \n    // Also try outgoing relationships\n    OPTIONAL MATCH (p)-[r2]->(xp2)\n    WHERE xp2.eventType = 'XP_GAIN' OR any(label IN labels(xp2) WHERE label CONTAINS 'XpGain')\n    \n    RETURN count(DISTINCT xp) AS incomingXpCount, count(DISTINCT xp2) AS outgoingXpCount\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:51"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:51"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find hit splat events directly\n    WITH p\n    OPTIONAL MATCH (hit)-[r1]->(p)\n    WHERE hit.eventType = 'HIT_SPLAT' OR any(label IN labels(hit) WHERE label CONTAINS 'HitSplat')\n    \n    // Also try outgoing relationships\n    OPTIONAL MATCH (p)-[r2]->(hit2)\n    WHERE hit2.eventType = 'HIT_SPLAT' OR any(label IN labels(hit2) WHERE label CONTAINS 'HitSplat')\n    \n    RETURN count(DISTINCT hit) AS incomingHitCount, count(DISTINCT hit2) AS outgoingHitCount\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:51"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:51"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find kill events directly\n    WITH p\n    OPTIONAL MATCH (kill)-[r1]->(p)\n    WHERE kill.eventType = 'MONSTER_KILL' OR any(label IN labels(kill) WHERE label CONTAINS 'MonsterKill')\n    \n    // Also try outgoing relationships\n    OPTIONAL MATCH (p)-[r2]->(kill2)\n    WHERE kill2.eventType = 'MONSTER_KILL' OR any(label IN labels(kill2) WHERE label CONTAINS 'MonsterKill')\n    \n    RETURN count(DISTINCT kill) AS incomingKillCount, count(DISTINCT kill2) AS outgoingKillCount\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:51"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:51"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Try to find any paths to XP, Hit, or Kill events\n    WITH p\n    \n    // Find XP events through any path up to 2 steps\n    OPTIONAL MATCH path1 = (p)-[*1..2]-(xp)\n    WHERE xp.eventType = 'XP_GAIN' OR any(label IN labels(xp) WHERE label CONTAINS 'XpGain')\n    \n    // Find HitSplat events through any path up to 2 steps\n    OPTIONAL MATCH path2 = (p)-[*1..2]-(hit)\n    WHERE hit.eventType = 'HIT_SPLAT' OR any(label IN labels(hit) WHERE label CONTAINS 'HitSplat')\n    \n    // Find Kill events through any path up to 2 steps\n    OPTIONAL MATCH path3 = (p)-[*1..2]-(kill)\n    WHERE kill.eventType = 'MONSTER_KILL' OR any(label IN labels(kill) WHERE label CONTAINS 'MonsterKill')\n    \n    RETURN count(DISTINCT path1) AS xpPaths, \n           count(DISTINCT path2) AS hitPaths,\n           count(DISTINCT path3) AS killPaths\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:51"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:51"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find ALL events connected in any way up to 2 steps\n    MATCH (p)-[*1..2]-(e)\n    WHERE e.eventType IS NOT NULL\n    \n    RETURN e.eventType AS type, count(e) AS count\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:51"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:51"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find XP events directly\n    WITH p\n    OPTIONAL MATCH (xp)-[r1]->(p)\n    WHERE xp.eventType = 'XP_GAIN' OR any(label IN labels(xp) WHERE label CONTAINS 'XpGain')\n    \n    // Also try outgoing relationships\n    OPTIONAL MATCH (p)-[r2]->(xp2)\n    WHERE xp2.eventType = 'XP_GAIN' OR any(label IN labels(xp2) WHERE label CONTAINS 'XpGain')\n    \n    RETURN count(DISTINCT xp) AS incomingXpCount, count(DISTINCT xp2) AS outgoingXpCount\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:52"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:52"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find hit splat events directly\n    WITH p\n    OPTIONAL MATCH (hit)-[r1]->(p)\n    WHERE hit.eventType = 'HIT_SPLAT' OR any(label IN labels(hit) WHERE label CONTAINS 'HitSplat')\n    \n    // Also try outgoing relationships\n    OPTIONAL MATCH (p)-[r2]->(hit2)\n    WHERE hit2.eventType = 'HIT_SPLAT' OR any(label IN labels(hit2) WHERE label CONTAINS 'HitSplat')\n    \n    RETURN count(DISTINCT hit) AS incomingHitCount, count(DISTINCT hit2) AS outgoingHitCount\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:52"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:52"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find kill events directly\n    WITH p\n    OPTIONAL MATCH (kill)-[r1]->(p)\n    WHERE kill.eventType = 'MONSTER_KILL' OR any(label IN labels(kill) WHERE label CONTAINS 'MonsterKill')\n    \n    // Also try outgoing relationships\n    OPTIONAL MATCH (p)-[r2]->(kill2)\n    WHERE kill2.eventType = 'MONSTER_KILL' OR any(label IN labels(kill2) WHERE label CONTAINS 'MonsterKill')\n    \n    RETURN count(DISTINCT kill) AS incomingKillCount, count(DISTINCT kill2) AS outgoingKillCount\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:52"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:52"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Try to find any paths to XP, Hit, or Kill events\n    WITH p\n    \n    // Find XP events through any path up to 2 steps\n    OPTIONAL MATCH path1 = (p)-[*1..2]-(xp)\n    WHERE xp.eventType = 'XP_GAIN' OR any(label IN labels(xp) WHERE label CONTAINS 'XpGain')\n    \n    // Find HitSplat events through any path up to 2 steps\n    OPTIONAL MATCH path2 = (p)-[*1..2]-(hit)\n    WHERE hit.eventType = 'HIT_SPLAT' OR any(label IN labels(hit) WHERE label CONTAINS 'HitSplat')\n    \n    // Find Kill events through any path up to 2 steps\n    OPTIONAL MATCH path3 = (p)-[*1..2]-(kill)\n    WHERE kill.eventType = 'MONSTER_KILL' OR any(label IN labels(kill) WHERE label CONTAINS 'MonsterKill')\n    \n    RETURN count(DISTINCT path1) AS xpPaths, \n           count(DISTINCT path2) AS hitPaths,\n           count(DISTINCT path3) AS killPaths\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:53"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:53"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find ALL events connected in any way up to 2 steps\n    MATCH (p)-[*1..2]-(e)\n    WHERE e.eventType IS NOT NULL\n    \n    RETURN e.eventType AS type, count(e) AS count\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:53"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:53"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find XP events directly\n    WITH p\n    OPTIONAL MATCH (xp)-[r1]->(p)\n    WHERE xp.eventType = 'XP_GAIN' OR any(label IN labels(xp) WHERE label CONTAINS 'XpGain')\n    \n    // Also try outgoing relationships\n    OPTIONAL MATCH (p)-[r2]->(xp2)\n    WHERE xp2.eventType = 'XP_GAIN' OR any(label IN labels(xp2) WHERE label CONTAINS 'XpGain')\n    \n    RETURN count(DISTINCT xp) AS incomingXpCount, count(DISTINCT xp2) AS outgoingXpCount\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:54"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:54"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find hit splat events directly\n    WITH p\n    OPTIONAL MATCH (hit)-[r1]->(p)\n    WHERE hit.eventType = 'HIT_SPLAT' OR any(label IN labels(hit) WHERE label CONTAINS 'HitSplat')\n    \n    // Also try outgoing relationships\n    OPTIONAL MATCH (p)-[r2]->(hit2)\n    WHERE hit2.eventType = 'HIT_SPLAT' OR any(label IN labels(hit2) WHERE label CONTAINS 'HitSplat')\n    \n    RETURN count(DISTINCT hit) AS incomingHitCount, count(DISTINCT hit2) AS outgoingHitCount\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:54"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:54"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find kill events directly\n    WITH p\n    OPTIONAL MATCH (kill)-[r1]->(p)\n    WHERE kill.eventType = 'MONSTER_KILL' OR any(label IN labels(kill) WHERE label CONTAINS 'MonsterKill')\n    \n    // Also try outgoing relationships\n    OPTIONAL MATCH (p)-[r2]->(kill2)\n    WHERE kill2.eventType = 'MONSTER_KILL' OR any(label IN labels(kill2) WHERE label CONTAINS 'MonsterKill')\n    \n    RETURN count(DISTINCT kill) AS incomingKillCount, count(DISTINCT kill2) AS outgoingKillCount\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:54"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:54"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Try to find any paths to XP, Hit, or Kill events\n    WITH p\n    \n    // Find XP events through any path up to 2 steps\n    OPTIONAL MATCH path1 = (p)-[*1..2]-(xp)\n    WHERE xp.eventType = 'XP_GAIN' OR any(label IN labels(xp) WHERE label CONTAINS 'XpGain')\n    \n    // Find HitSplat events through any path up to 2 steps\n    OPTIONAL MATCH path2 = (p)-[*1..2]-(hit)\n    WHERE hit.eventType = 'HIT_SPLAT' OR any(label IN labels(hit) WHERE label CONTAINS 'HitSplat')\n    \n    // Find Kill events through any path up to 2 steps\n    OPTIONAL MATCH path3 = (p)-[*1..2]-(kill)\n    WHERE kill.eventType = 'MONSTER_KILL' OR any(label IN labels(kill) WHERE label CONTAINS 'MonsterKill')\n    \n    RETURN count(DISTINCT path1) AS xpPaths, \n           count(DISTINCT path2) AS hitPaths,\n           count(DISTINCT path3) AS killPaths\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:54"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:54"}
{"level":"error","message":"Neo4j error: Expected parameter(s): playerId","params":{"account":"oauth2|discord|177946696251211776"},"query":"\n    MATCH (p:Player {account: $account, playerId: $playerId})\n    \n    // Find ALL events connected in any way up to 2 steps\n    MATCH (p)-[*1..2]-(e)\n    WHERE e.eventType IS NOT NULL\n    \n    RETURN e.eventType AS type, count(e) AS count\n  ","service":"mindrune-api","timestamp":"2025-03-30 18:12:54"}
{"level":"error","message":"500 - Neo4j error: Expected parameter(s): playerId - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:12:54"}
{"level":"error","message":"Neo4j error: Variable `players` not defined (line 55, column 45 (offset: 1915))\n\"            WHERE n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\"\n                                             ^","params":{"account":"oauth2|discord|177946696251211776","playerId":-1617514147593677000},"query":"\n        // First match the specific player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect ALL incoming relationships\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            // For hit splats, ensure the targetPlayerId matches to prevent cross-player hits\n            WHERE NOT (e:HitSplat AND e.direction = \"incoming\") OR e.targetPlayerId = p.playerId\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect ALL outgoing relationships\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN player_events[0..300] AS limited_events\n        }\n        \n        // Collect events with the original player\n        WITH p, limited_events\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 18:17:22"}
{"level":"error","message":"500 - Neo4j error: Variable `players` not defined (line 55, column 45 (offset: 1915))\n\"            WHERE n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\"\n                                             ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:17:22"}
{"level":"error","message":"Neo4j error: Variable `players` not defined (line 55, column 45 (offset: 1915))\n\"            WHERE n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\"\n                                             ^","params":{"account":"oauth2|discord|177946696251211776","playerId":8635364660489471000},"query":"\n        // First match the specific player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect ALL incoming relationships\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            // For hit splats, ensure the targetPlayerId matches to prevent cross-player hits\n            WHERE NOT (e:HitSplat AND e.direction = \"incoming\") OR e.targetPlayerId = p.playerId\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect ALL outgoing relationships\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN player_events[0..300] AS limited_events\n        }\n        \n        // Collect events with the original player\n        WITH p, limited_events\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 18:17:23"}
{"level":"error","message":"500 - Neo4j error: Variable `players` not defined (line 55, column 45 (offset: 1915))\n\"            WHERE n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\"\n                                             ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:17:23"}
{"level":"error","message":"Neo4j error: Variable `players` not defined (line 55, column 45 (offset: 1915))\n\"            WHERE n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\"\n                                             ^","params":{"account":"oauth2|discord|177946696251211776","playerId":-1617514147593677000},"query":"\n        // First match the specific player\n        MATCH (p:Player {account: $account, playerId: $playerId})\n        \n        // Use CALL blocks for better parallel execution\n        CALL {\n          WITH p\n          \n          // Collect ALL incoming relationships\n          CALL {\n            WITH p\n            MATCH (e)-[r]->(p)\n            // For hit splats, ensure the targetPlayerId matches to prevent cross-player hits\n            WHERE NOT (e:HitSplat AND e.direction = \"incoming\") OR e.targetPlayerId = p.playerId\n            RETURN collect(DISTINCT e) AS incoming_events\n          }\n          \n          // Collect ALL outgoing relationships\n          CALL {\n            WITH p\n            MATCH (p)-[r]->(e)\n            RETURN collect(DISTINCT e) AS outgoing_events\n          }\n          \n          WITH p, incoming_events + outgoing_events AS player_events\n          RETURN player_events[0..300] AS limited_events\n        }\n        \n        // Collect events with the original player\n        WITH p, limited_events\n        \n        // Collect players and events\n        WITH collect({player: p, events: limited_events}) AS player_data\n        \n        // Process relationships more efficiently using CALL blocks\n        CALL {\n          WITH player_data\n          UNWIND player_data AS pd\n          UNWIND pd.events AS event\n          WITH collect(DISTINCT pd.player) AS players, collect(DISTINCT event) AS events\n          \n          // Use parallel CALL blocks for relationship collection\n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (e)-[r1]->(n1)\n            WHERE NOT type(r1) = \"PART_OF\"\n            RETURN collect(DISTINCT n1) AS out_entities, collect(DISTINCT r1) AS out_rels\n          }\n          \n          CALL {\n            WITH events\n            UNWIND events AS e\n            MATCH (n2)-[r2]->(e)\n            WHERE n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\n            RETURN collect(DISTINCT n2) AS in_entities, collect(DISTINCT r2) AS in_rels\n          }\n          \n          RETURN players, events, out_entities + in_entities AS entities, out_rels + in_rels AS relationships\n        }\n        \n        RETURN players, events, entities, relationships\n        ","service":"mindrune-api","timestamp":"2025-03-30 18:17:24"}
{"level":"error","message":"500 - Neo4j error: Variable `players` not defined (line 55, column 45 (offset: 1915))\n\"            WHERE n2:Player OR NOT any(p IN players WHERE n2.playerId = p.playerId)\"\n                                             ^ - /osrs/query - POST - ::1","service":"mindrune-api","timestamp":"2025-03-30 18:17:24"}
